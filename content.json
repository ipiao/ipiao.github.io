[{"title":"docker安装","date":"2019-04-27T04:48:00.000Z","path":"2019/04/27/docker安装/","text":"正式环境不能像开发环境一样随意.. 网桥 12345678910 cat &gt;&gt; /etc/sysctl.conf&lt;&lt;EOFnet.ipv4.ip_forward=1net.bridge.bridge-nf-call-iptables=1net.ipv4.neigh.default.gc_thresh1=4096net.ipv4.neigh.default.gc_thresh2=6144net.ipv4.neigh.default.gc_thresh3=8192EOF# 这个其实是重启命令init 6 如果已经安装高版本Docker,可进行降级安装(可选) 1 yum downgrade --setopt=obsoletes=0 -y docker-ce-$&#123;version&#125; docker-ce-selinux-$&#123;version&#125; 卸载旧版本Docker软件 123456789101112131415161718192021222324 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine \\ container*sudo adduser dockersudo echo 'docker ALL=(ALL) ALL' &gt;&gt; /etc/sudoersexport docker_version=17.03.2sudo yum update -ysudo yum install -y yum-utils device-mapper-persistent-data lvm2 bash-completionsudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.reposudo yum makecache allversion=$(yum list docker-ce.x86_64 --showduplicates | sort -r|grep $&#123;docker_version&#125;|awk '&#123;print $2&#125;')sudo yum -y install --setopt=obsoletes=0 docker-ce-$&#123;version&#125; docker-ce-selinux-$&#123;version&#125;sudo usermod -aG docker dockersudo systemctl enable docker 物理机需要增加overlay2，云服务器已是overlay2。不需要这配置 123456789101112131415161718 vi /etc/docker/daemon.json&#123;\"max-concurrent-downloads\": 3,\"max-concurrent-uploads\": 5,\"registry-mirrors\": [\"https://a9wm3lf0.mirror.aliyuncs.com\"],\"graph\": \"/home/docker\",\"storage-driver\": \"overlay2\",\"storage-opts\": [\"overlay2.override_kernel_check=true\"],\"log-driver\": \"json-file\",\"log-opts\": &#123; \"max-size\": \"100m\", \"max-file\": \"3\" &#125;&#125; WARNING: bridge-nf-call-ip6tables is disabled 123456 vi /etc/sysctl.confnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1sysctl -p","tags":[{"name":"sh","slug":"sh","permalink":"http://ipiao.top/tags/sh/"}]},{"title":"sh字符串截取","date":"2019-04-27T04:17:00.000Z","path":"2019/04/27/sh字符串截取/","text":"sh字符串截取 *的位置,代表删除侧边 #号截取，* 删除从左边满足条件的第一组字符及其左边字符，保留右边字符。 123 var=http://www.aaa.com/123.htm.echo $&#123;var#*//&#125; # www.aaa.com/123.htm.echo $&#123;var#*/&#125; # /www.aaa.com/123.htm. ##号截取，* 删除从右边满足条件的第一组字符及其左边字符，保留右边字符 123 var=http://www.aaa.com/123.htm.echo $&#123;var##*//&#125; # www.aaa.com/123.htm.echo $&#123;var##*/&#125; # 123.htm. %号截取，* 删除从左边满足条件的第一组字符及其左边字符，保留左边字符 123 var=http://www.aaa.com/123.htm.echo $&#123;var%//*&#125; # http:echo $&#123;var%/*&#125; # http://www.aaa.com %%号截取，* 删除从右边满足条件的第一组字符及其左边字符，保留左边字符 123 var=http://www.aaa.com/123.htm.echo $&#123;var%%//*&#125; # http:echo $&#123;var%%/*&#125; # http: 下标截取(开始位置+长度)(负数下标表示从右边数) 123 var=http://www.aaa.com/123.htm.echo $&#123;var:0:5&#125; # http:echo $&#123;var:0:-1&#125; # http://www.aaa.com/123.htm. 缺省下标(个数)截取 12 var=http://www.aaa.com/123.htm.echo $&#123;var:5&#125; # www.aaa.com/123.htm.","tags":[{"name":"sh","slug":"sh","permalink":"http://ipiao.top/tags/sh/"}]},{"title":"ssh-config","date":"2019-04-27T03:52:00.000Z","path":"2019/04/27/ssh-config/","text":"ssh 配置说明 位置:一般是 ~/./ssh/config,文件存在直接创建即可. 格式: 1234567 Host test # 随意命名 HostName 118.25.7.38 User root Port 22 IdentityFile ~/.ssh/id_rsa # 指定密钥文件 # ProxyCommand ssh test2 -W '%h %p' # 跳板机跳转 # ProxyCommand sshpass -p pwd ssh %u@%h # 账号密码免输入密码登录 通过 ssh test 就可以登录服务器 ssh-keygen -t rsa 生成自己的密钥 ssh-copy-id 可以在账号密码登录后将自己的密钥拷贝到服务器,以后就可以不用账号密码(支持的情况下) ssh 执行多命令(其实是 &lt;&lt; EOF 的使用) 1234567 ssh $host &lt;&lt;EOF cd $path mv $tmpbinaryname $binaryname cp $binaryname $cmd cd $cmd nohup ./$binaryname 2&gt;&amp;1 &amp;EOF 6.1 脚本执行可能会在退出的时候切断服务,是由于进程间的依赖关系造成的,可以加 setsid, 如 setsid nohup ./$binaryname 2&gt;&amp;1 &amp; scp, 依赖ssh. scp $binaryname $host:$path/$tmpbinaryname,上传到服务器 7.1 scp $host:$path/$tmpbinaryname $binaryname,反过来就是从服务器下载","tags":[{"name":"sh","slug":"sh","permalink":"http://ipiao.top/tags/sh/"}]},{"title":"文件监听 inotify","date":"2019-04-27T03:17:00.000Z","path":"2019/04/27/文件监听-inotify/","text":"inotify文件事件的自动化部署 需要安装,补充inotify命令inotify-tools,inotifywait. 1 sudo apt-get(yum) install inotify-tools inotifywait -h 了解其使用方法 基于文件事件的自动化部署 1.需求: 由于公司所有服务器采用跳板机(jumpserver)登录方式,目前无法通过任何方式进行直连以及文件的直接传输,于是乎,程序更新部署(尤其是测试环境)显得及其麻烦.当前只能通过将程序文件上传(ftp)到目的服务器临时目录 /tmp,然后再进行二次操作. 2.解决方案: 考虑二次操作,有几个解决方案,其中2个比较代表性的是: 2.1 通过supervisord配置,界面管理重启. 2.2 通过文件监听inotifywait自己实现监听重启脚本 3.方案对比 3.1 supervisord劣势: 需要额外的配置文件,需要开放管理界面端口,(根据以往的经验,)容易失效 3.2 supervisord优势: 界面管理,可以随时重启当前服务 3.3 inotifywait劣势: 每次重启需要手动出发事件(相当于去supervisord界面点击一下),但是要通过jumpserver的界面去操作,中间多了好几步. 3.4 inotifywait优势: 安装简单(就是一个安装命令和一个监听脚本),根据自己的服务特性写脚本足够灵活(不必重复的配置文件) 微服务配置脚本 由于完全自己开发,所有的脚本,配置格式都比较统一,所以脚本不会复杂 1234567891011121314151617181920212223242526272829303132333435363738394041424344 #!/usr/bin/env bash# 监听文件夹改动并自动编译重启SRCDIR=`pwd`dorestart()&#123; sleep 2 echo \"restart $1\" cd \"/srv/onevideo/$1\" f=\"1v1_$1\" tmpfile=\"/tmp/onevideo/$1/$f\" if [ ! -f $tmpfile ]; then return fi setsid sh restart.sh &amp; # mv $tmpfile ./ # chmod +x $f # ps -aux|grep $f|grep -v grep|awk '&#123;print $2&#125;'|xargs kill -15 # 2|3|15 # sleep 2 # dt=`date \"+%m%d_%H%M\"` # if [ ! -d logs_bak ]; then # mkdir logs_bak # fi # mv \"$1.log\" \"logs_bak/$1\"_\"$dt.log\" # setsid nohup ./$f -c \"server.yaml\" --registry_address \"127.0.0.1:8500\" 2&gt;&amp;1 &gt;&gt;\"$1.log\" &amp; cd $SRCDIR if [ ! -f \"$1/EOF\" ]; then touch \"$1/EOF\" fi # setsid sh restart.sh &amp; echo \"restart $1 done\"&#125;# 这里 format 定义输出的日志格式, read类似程序里的scan(将输入读取到指定变量的意思)inotifywait -mrq --timefmt '%d/%m/%y %H:%M' --format '%T %Xe %w %f' \\ -e DELETE,CREATE --excludei *.* $SRCDIR/* | while read DATE TIME EVENT DIR FILE; doRDIR=$&#123;DIR%/&#125;dir=$&#123;RDIR##*/&#125;echo \"notify $EVENT:$dir-$FILE\" # if [ \"CLOSE_WRITEXCLOSE\" == \"$EVENT\" ] #CLOSE事件不止一次发生,并且暂时不知道怎么判断文件上传结束if [ \"EOF\" == \"$FILE\" ] # 通过EOF文件标记上传结束then dorestart $dirfidone 说明: 略 操作: 每次上传完新程序文件,只需要删除对应目录下(自动生成的)EOF文件即可重启 执行: 不用 -d的原因是 -d -o 执行的时候出现了问题(提示日志文件权限之类的,没有细查…) 为什么不监听文件上传完成后重启 大文件断续上传,会产生好几个CREATE\\CLOSE事件,不好判断(主要是我也不会)文件是否真的完整上传完成. 上传时就在同一个目录下,删除一个EOF文件足够简单.并且这样还可以支持无更新重启(虽然上面脚本没支持) 动作缓冲,潜意识提醒你检查服务状态^0_0*","tags":[{"name":"sh","slug":"sh","permalink":"http://ipiao.top/tags/sh/"}]},{"title":"数字游戏","date":"2019-01-22T06:42:00.000Z","path":"2019/01/22/数字游戏/","text":"数学猜心魔术 让对方随便写一个五位数（五个数字各不相同，例如：37415） 用这五位数的五个数字再随意组成另外一个五位数 （例如：75314） 用这两个五位数相减（大数减小数，75314-37415=37899） 让对方记住得数中的任意一个数字，再把得数的其他数字告诉你 。（例如，我记住了“7”，把3899告诉你。） 你只要把对方告诉你的那几个数字一直相加到一位数，然后用9减就可以知道对方想的是什么数了 （你就把3899作一个简单的处理，3+8+9+9=29，所得的和还是一个两位数，你就继续处理2+9=11，继续处理1+1=2，最后得到一位数2以后，用最大的一位数9去减，9-2=7，那么你就猜到他心里记住的是7了。）","tags":[{"name":"数","slug":"数","permalink":"http://ipiao.top/tags/数/"},{"name":"魔术","slug":"魔术","permalink":"http://ipiao.top/tags/魔术/"}]},{"title":"scrapy爬虫-英语考研词汇","date":"2019-01-11T08:16:00.000Z","path":"2019/01/11/scrapy爬虫-英语考研词汇/","text":"scapy爬虫-考研英语词汇 之前都是用go语言爬虫的，学习了一点python，尝试着用scrapy框架爬虫 爬虫之前需要大致了解一下scarpy框架，官方文档实在看的累，找了一个中文翻译的简要了解了一下，地址是(http://www.scrapyd.cn/doc/165.html) 爬取的扇贝网的英语词汇(https://www.shanbay.com/wordbook/34/)， 虽然网页访问是要登录的，但是实际爬虫幷不需要。 1.扇贝网的文档结构十分统一 2.右上角的搜索框，搜一个单词，很容易就通过调试获取到单词信息接口 3.接口有次数限制，最好控制一下频率或者使用代理 于是，根据以上两点，很容易就能做到这个爬虫。而且由于结构的一致性，稍加修改，就能扩展到所有词汇的爬虫。 就英语考研词汇而言，内容有限，直接将最后的结果存储到json文件就可以了 具体代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121 # -*- coding: utf-8 -*-import scrapyimport timeimport jsonimport urllib3import randomclass WordbookSpider(scrapy.Spider): wl = [] failedwds = [] name = 'wordbook' allowed_domains = ['www.shanbay.com'] book = '34' file = None tmp_fp = None succ_fp = None successws = [] proxys = [ \"http://124.207.82.166:8008\" ] proxyManagers = [] def randproxy(self): return random.choice(self.proxyManagers) def start_requests(self): url = \"http://www.shanbay.com/wordbook/\" book = getattr(self, 'book', None) # 获取tag值，也就是爬取时传过来的参数 if book is not None: self.book = book url = url + self.book # 构造url file = getattr(self, 'file') if file is None: self.file = \"shanbei_wordbook_\" + self.book + \".json\" else: self.file = file tmpfile = \"shanbei_wordbook_\" + self.book + \"_tmp.json\" self.tmp_fp = open(tmpfile, 'a', encoding='utf-8') successfile = \"shanbei_wordbook_\" + self.book + \"_success.txt\" self.succ_fp = open(successfile, 'a', encoding='utf-8') # self.successws = self.succ_fp.readlines() for proxy in self.proxys: try: if proxy == \"\": pool = urllib3.PoolManager(num_pools=5) else: pool = urllib3.ProxyManager(proxy_url=proxy, num_pools=5) except Exception as e: print(\"can not conn:\", proxy, e) continue self.proxyManagers.append(pool) yield scrapy.Request(url, self.parse) # 发送请求爬取参数内容 def parse(self, response): ll = response.xpath('//*[@id=\"wordbook-wordlist-container\"]') for l in ll: wa = l.css('a::attr(href)').extract() for w in wa: next_page = response.urljoin(w) + \"?page=1\" yield scrapy.Request(next_page, callback=self.parsewds) # 避免一次性操作失败,可以分文件存储或者每一次查找到结果后存储到临时文件,最后统一处理格式 def parsewds(self, response): ll = response.xpath('/html/body/div[3]/div/div[1]/div[2]/div/table') wl = ll.xpath(\"//td[@class='span2']/strong//text()\").extract() for w in wl: if w not in self.successws: # print(w) self.searchword(w) time.sleep(0.001) # pass if len(wl) &gt; 1: time.sleep(1) ss = response.url.split('page=') page = int(ss[len(ss)-1]) next_page = ss[0] + \"page=\" + str(page+1) yield scrapy.Request(next_page, callback=self.parsewds) def searchword(self, w, first=True): r = self.randproxy().request(\"GET\", self.makesearchpath(w), retries=2) resp = json.loads(r.data, encoding=\"utf-8\") # resp = requests.get(self.makesearchpath(w)).json(encoding=\"utf-8\") print(resp) if resp['status_code'] == 0: data = resp['data'] data['word'] = w self.succ_fp.write(w) self.succ_fp.write(\"\\n\") self.wl.append(data) json.dump(data, self.tmp_fp, ensure_ascii=False) self.tmp_fp.write(\",\\n\") else: if first: self.searchword(w) else: self.failedwds.append(w) print(data) def makesearchurl(self, w): tm = int(time.time()*1000) url = \"/api/v1/bdc/search/?version=2&amp;word=&#123;&#125;&amp;_=&#123;&#125;\".format(w, tm) return url def makesearchpath(self, w): tm = int(time.time()*1000) path = \"http://www.shanbay.com/api/v1/bdc/search/?version=2&amp;word=&#123;&#125;&amp;_=&#123;&#125;\".format(w, tm) return path def close(self, spider, reason): self.wl.sort(key=lambda w: w['word'].lower()) fp = open(self.file, 'w', encoding='utf-8') json.dump(self.wl, fp, ensure_ascii=False, indent=4) print(\"failed words\", self.failedwds) fp.close() super().close(spider, reason) 运行 1 scrapy crawl wordbook -a book=34 全部过程 12345678910 #### 安装包pip install scrapy#### 创建项目scrapy startproject xxx#### 生成爬虫文件scrapy genspider -t basic wordbook https://www.shanbay.com/wordbook/#### 写代码#### 执行scrapy crawl wordbook -a book=34","tags":[{"name":"python","slug":"python","permalink":"http://ipiao.top/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://ipiao.top/tags/爬虫/"}]},{"title":"Leetcode 31-40","date":"2018-12-29T10:22:00.000Z","path":"2018/12/29/Leetcode-31-40/","text":"31. 下一个排列 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 解: 重点在于下一个的规则 code 12345678910111213141516171819202122232425262728293031323334 func nextPermutation(nums []int) &#123; for i:=len(nums) -1; i&gt;0; i-- &#123; if nums[i] &gt; nums[i-1]&#123; ind:=i for j:=i+1;j&lt;len(nums);j++&#123; if nums[j]&gt;nums[i-1] &amp;&amp; nums[j] &lt;= nums[ind]&#123; ind = j &#125; &#125; swap(nums, ind, i-1) reverse(nums[i:]) return &#125; &#125; reverse(nums)&#125;func reverse(nums []int) &#123; i := 0 j := len(nums) -1 for i &lt; j &#123; swap(nums,i,j) i++; j--; &#125;&#125;func swap(nums []int,i ,j int)&#123; tmp := nums[i] nums[i] = nums[j] nums[j] = tmp&#125; 32. 最长有效括号 给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。 code 1234567891011121314151617181920212223 func longestValidParentheses(s string) int &#123; bytes := []byte(s) if len(bytes) &lt; 2 &#123; return 0 &#125; lengthList := make([]int, len(bytes)) var max int for i := 1; i &lt; len(bytes); i++ &#123; if bytes[i] == ')' &#123; j := i - lengthList[i-1] - 1 if j &gt;= 0 &amp;&amp; bytes[j] == '(' &#123; lengthList[i] = lengthList[i-1] + 2 if j-1 &gt;= 0 &#123; lengthList[i] += lengthList[j-1] &#125; &#125; &#125; if lengthList[i] &gt; max &#123; max = lengthList[i] &#125; &#125; return max&#125; 33. 搜索旋转排序数组 假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 O(log n) 级别。 code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 func search(nums []int, target int) int &#123; length := len(nums) if length == 0 &#123; return -1 &#125; if length == 1 &#123; if nums[0] != target &#123; return -1 &#125; return 0 &#125; return search1(nums, 0, length-1, target)&#125;func search1(nums []int, left, right, target int) int &#123; if left &gt; right &#123; return -1 &#125; if left == right &#123; if nums[left] == target &#123; return left &#125; return -1 &#125; mid := left + (right-left)/2 if nums[mid] == target &#123; return mid &#125; if nums[left] &lt; nums[mid] &amp;&amp; nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target &#123; return binarySearch(nums, left, mid-1, target) &#125; if nums[right] &gt; nums[mid] &amp;&amp; nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target &#123; return binarySearch(nums, mid+1, right, target) &#125; if nums[left] &gt; nums[mid] &#123; return search1(nums, left, mid-1, target) &#125; if nums[right] &lt; nums[mid] &#123; return search1(nums, mid+1, right, target) &#125; return -1&#125;func binarySearch(nums []int, left, right, target int) int &#123; if left &gt; right &#123; return -1 &#125; mid := left + (right-left)/2 if nums[mid] == target &#123; return mid &#125; if target &lt; nums[mid] &#123; return binarySearch(nums, left, mid-1, target) &#125; return binarySearch(nums, mid+1, right, target)&#125; 34. 在排序数组中查找元素的第一个和最后一个位置 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]。 code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 func searchRange(nums []int, target int) []int &#123; length := len(nums) if length == 0 || length == 1 &amp;&amp; nums[0] != target &#123; return []int&#123;-1, -1&#125; &#125; return searchRangeI(nums, 0, length-1, target)&#125;func searchRangeI(nums []int, left, right, target int) (ret []int) &#123; length := len(nums) if length == 0 || left &gt; right &#123; return []int&#123;-1, -1&#125; &#125; if left == right &#123; if nums[left] == target &#123; return []int&#123;left, left&#125; &#125; return []int&#123;-1, -1&#125; &#125; mid := left + (right-left)/2 if nums[mid] == target &#123; lower := findLower(nums, left, mid, target) upper := findUpper(nums, mid, right, target) return []int&#123;lower, upper&#125; &#125; else if nums[mid] &lt; target &#123; return searchRangeI(nums, mid+1, right, target) &#125; return searchRangeI(nums, left, mid-1, target)&#125;func findLower(nums []int, left, right, target int) int &#123; length := len(nums) if length == 0 || left &gt; right &#123; return -1 &#125; if left == right &#123; if nums[right] == target &#123; return right &#125; return -1 &#125; mid := left + (right-left)/2 if nums[mid] == target &#123; if mid &gt; left &amp;&amp; nums[mid-1] == target &#123; return findLower(nums, left, mid-1, target) &#125; return mid &#125; return findLower(nums, mid+1, right, target)&#125;func findUpper(nums []int, left, right, target int) int &#123; length := len(nums) if length == 0 || left &gt; right &#123; return -1 &#125; if left == right &#123; if nums[left] == target &#123; return left &#125; return -1 &#125; mid := left + (right-left)/2 if nums[mid] == target &#123; if mid &lt; right &amp;&amp; nums[mid+1] == target &#123; return findUpper(nums, mid+1, right, target) &#125; return mid &#125; return findUpper(nums, left, mid-1, target)&#125; 35. 搜索插入位置 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。 code 123456789101112131415161718192021222324252627 func searchInsert(nums []int, target int) int &#123; if len(nums) == 0&#123; nums = append(nums, target) return 0 &#125; return find(nums, 0, len(nums)-1, target)&#125;func find(nums []int, left, right ,target int) int&#123; if left == right&#123; if nums[left] &gt;= target&#123; return left &#125;else&#123; return right+1 &#125; &#125; mid := left + (right - left)/2 if nums[mid] == target&#123; return mid &#125; if nums[mid] &gt; target&#123; return find(nums, left, mid, target) &#125; return find(nums, mid+1, right, target)&#125; 36. 有效的数独 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。上图是一个部分填充的有效的数独。数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 code 12345678910111213141516171819202122232425262728293031323334353637383940 func isValidSudoku(board [][]byte) bool &#123; rows := [9][9]byte&#123;&#125; squars := [9][9]byte&#123;&#125; list := [9][9]byte&#123;&#125; for i, sb := range board &#123; for j := range sb &#123; rows[j][i] = sb[j] squars[(i/3)*3+(j/3)][(i%3)*3+(j%3)] = sb[j] list[i][j] = sb[j] &#125; &#125; for _, row := range list &#123; if hasRepeted(row) &#123; return false &#125; &#125; for _, row := range rows &#123; if hasRepeted(row) &#123; return false &#125; &#125; for _, row := range squars &#123; if hasRepeted(row) &#123; return false &#125; &#125; return true&#125;func hasRepeted(bs [9]byte) bool &#123; for i := 0; i &lt; len(bs)-1; i++ &#123; for j := i + 1; j &lt; len(bs); j++ &#123; if bs[i] != '.' &amp;&amp; bs[i] == bs[j] &#123; return true &#125; &#125; &#125; return false&#125; 37. 解数独 编写一个程序，通过已填充的空格来解决数独问题。一个数独的解法需遵循如下规则：数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。空白格用 ‘.’ 表示。 一个数独。 答案被标成红色。Note:给定的数独序列只包含数字 1-9 和字符 ‘.’ 。你可以假设给定的数独只有唯一解。给定数独永远是 9x9 形式的。 解: 暴力递归 38. 报数 报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 1 11 21 1211 1112211 被读作 “one 1” (“一个一”) , 即 11。11 被读作 “two 1s” (“两个一”）, 即 21。21 被读作 “one 2”, “one 1” （”一个二” , “一个一”) , 即 1211。给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。注意：整数顺序将表示为一个字符串。 code 1234567891011121314151617181920 func countAndSay(n int) string &#123; if n == 1 &#123; return \"1\" &#125; base := countAndSay(n - 1) i := 0 count := 1 ret := \"\" for j := 1; j &lt; len(base); j++ &#123; if base[j] == base[i] &#123; count++ &#125; else &#123; ret += fmt.Sprint(count, string(base[i])) i = j count = 1 &#125; &#125; ret += fmt.Sprint(count, string(base[i])) return ret&#125; 39. 组合总和 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。说明：所有数字（包括 target）都是正整数。解集不能包含重复的组合。 code 12345678910111213141516171819202122232425262728 func combinationSum(candidates []int, target int) [][]int &#123; sort.Ints(candidates) return cbs(candidates,0, target)&#125;func cbs(nums []int,start, target int) [][]int&#123; if target &lt;= 0 || nums[start] &gt; target&#123; return nil &#125; ret := [][]int&#123;&#125; if nums[start] == target&#123; ret = append(ret, []int&#123;nums[start]&#125;) return ret &#125; rs := cbs(nums, start, target-nums[start]) for _,r1:=range rs&#123; nr := make([]int, len(r1)+1) nr[0] = nums[start] copy(nr[1:], r1) ret = append(ret, nr) &#125; if start &lt; len(nums)-1&#123; ret = append(ret, cbs(nums, start+1, target)...) &#125; return ret&#125; 40. 组合总和 II 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。说明：所有数字（包括目标数）都是正整数。解集不能包含重复的组合。 code 123456789101112131415161718192021222324252627 func combinationSum2(candidates []int, target int) [][]int &#123; sort.Ints(candidates) return DFS(candidates, 0, target, []int&#123;&#125;, [][]int&#123;&#125;)&#125;func DFS(candidates []int, start int, target int, solution []int, results [][]int) (rets [][]int) &#123; rets = results if target &lt; 0 &#123; return &#125; if target == 0 &#123; rets = append(rets, solution) return &#125; for i := start; i &lt; len(candidates); i++ &#123; if i &gt; start &amp;&amp; candidates[i] == candidates[i-1] &#123; continue &#125; candidate := candidates[i] repliaSolution := make([]int, len(solution)) copy(repliaSolution, solution) repliaSolution = append(repliaSolution, candidate) rets = DFS(candidates, i+1, target-candidate, repliaSolution, rets) repliaSolution = repliaSolution[:len(repliaSolution)-1] &#125; return&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://ipiao.top/tags/leetcode/"}]},{"title":"Leetcode 21-30","date":"2018-12-27T07:17:00.000Z","path":"2018/12/27/Leetcode-21-30/","text":"21. 合并两个有序链表 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 code 123456789101112131415161718192021222324252627 /** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; if l1 == nil &#123; return l2 &#125; if l2 == nil &#123; return l1 &#125; var root = new(ListNode) if l1.Val &lt; l2.Val&#123; root.Val = l1.Val l1 = l1.Next &#125;else&#123; root.Val = l2.Val l2 = l2.Next &#125; if l1 !=nil || l2!=nil&#123; root.Next = mergeTwoLists(l1, l2) &#125; return root&#125; 22. 括号生成 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。例如，给出 n = 3，生成结果为：[ “((()))”, “(()())”, “(())()”, “()(())”, “()()()”] code 123456789101112131415161718 func generateParenthesis(n int) []string &#123; var ans = []string&#123;&#125; generate(&amp;ans, \"\", 0, 0, n) return ans&#125;func generate(ans *[]string,cur string,l int, r int, max int) &#123; if len(cur) == max*2&#123; *ans = append(*ans, cur) &#125; if l &lt; max&#123; generate(ans, cur + \"(\", l+1, r, max) &#125; if r &lt; l&#123; generate(ans, cur + \")\", l, r+1, max) &#125;&#125; 23. 合并K个排序链表 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 code 123456789101112131415161718 /** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func mergeKLists(lists []*ListNode) *ListNode &#123; if len(lists) == 0 &#123; return nil &#125; if len(lists) == 1&#123; return lists[0] &#125; return mergeTwoLists(mergeKLists(lists[:len(lists)/2]), mergeKLists(lists[len(lists)/2:]))&#125; 24. 两两交换链表中的节点 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。示例:给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.说明:你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 code 1234567891011121314151617 /** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func swapPairs(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil&#123; return head &#125; p := head head = head.Next p.Next = swapPairs(head.Next) head.Next = p return head&#125; 25. k个一组翻转链表 给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保&gt; 持原有顺序。示例 :给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5说明 :你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 code 123456789101112131415161718192021222324252627282930313233343536373839404142434445 /** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func reverseKGroup(head *ListNode, k int) *ListNode &#123; if k == 1&#123; return head &#125; fake := &amp;ListNode&#123;Next: head&#125; p := fake for p != nil&#123; p.Next = reverseKNodes(p.Next, k) for i:=0; p!=nil &amp;&amp; i&lt;k; i++&#123; p = p.Next &#125; &#125; return fake.Next&#125;func reverseKNodes(head *ListNode, k int) *ListNode &#123; end := head for end != nil &amp;&amp; k&gt;0&#123; // end 是结束后一个 end = end.Next k-- &#125; if k &gt; 0&#123; return head &#125; var qNode *ListNode var ret = end var node = head for node != end &#123; qNode = node.Next node.Next = ret ret = node node = qNode &#125; return ret&#125; 26. 删除排序数组中的重复项 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 code 1234567891011121314 func removeDuplicates(nums []int) int &#123; if len(nums) &lt;= 1&#123; return len(nums) &#125; newLen:=1 base:=nums[0] for i:=1; i&lt;len(nums); i++&#123; if nums[i] != base&#123; nums[newLen],newLen,base = nums[i],newLen+1,nums[i] &#125; &#125; return newLen&#125; 27. 移除元素 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 code 123456789101112 func removeElement(nums []int, val int) int &#123; ind:=0 ret:=0 for i:=range nums&#123; if nums[i] != val&#123; ret++ nums[ind] = nums[i] ind++ &#125; &#125; return ret&#125; 28. 实现strStr() 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 解: 经典 KMP 算法 code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 func strStr(haystack string, needle string) int &#123; if needle == \"\"&#123; return 0 &#125; return kmpIndex([]byte(haystack), []byte(needle))&#125;func kmpIndex(s, p []byte) int &#123; i := 0 j := 0 next := getNext(p) for i &lt; len(s) &amp;&amp; j &lt; len(p) &#123; if j == -1 || s[i] == p[j] &#123; i++ j++ &#125; else &#123; j = next[j] &#125; &#125; if j == len(p) &#123; return i - j &#125; return -1&#125;func getNext(ms []byte) []int &#123; length := len(ms) next := make([]int, length) next[0] = -1 k := -1 j := 0 for j &lt; length-1 &#123; if k == -1 || ms[j] == ms[k] &#123; j++ k++ if ms[j] != ms[k] &#123; next[j] = k &#125; else &#123; next[j] = next[k] &#125; &#125; else &#123; k = next[k] &#125; &#125; return next&#125; 29. 两数相除 给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。返回被除数 dividend 除以除数 divisor 得到的商。示例 1:输入: dividend = 10, divisor = 3输出: 3示例 2:输入: dividend = 7, divisor = -3输出: -2说明:被除数和除数均为 32 位有符号整数。除数不为 0。我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 解: 分治法 code 12345678910111213141516171819202122232425262728293031323334353637383940 func divide(dividend int, divisor int) int &#123; if dividend &lt; 0&#123; if dividend &gt; math.MinInt32&#123; if divisor == math.MinInt32&#123; return 0 &#125;else&#123; return divide(0-dividend, 0-divisor) &#125; &#125;else&#123; if divisor == math.MinInt32&#123; return 1 &#125;else if divisor == -1&#123; return math.MaxInt32 &#125; else&#123; if divisor &gt; 0&#123; return divide(divisor+dividend, divisor)-1 &#125;else&#123; return divide(dividend-divisor, divisor)+1 &#125; &#125; &#125; &#125; ret := 0 if divisor &gt; 0&#123; sum := divisor for sum &lt;= dividend&#123; ret++ sum += divisor &#125; &#125;else&#123; sum := 0-divisor for sum &lt;= dividend &#123; ret-- sum -= divisor &#125; &#125; return ret&#125; 30. 与所有单词相关联的字串 给定一个字符串 s 和一些长度相同的单词 words。在 s 中找出可以恰好串联 words 中所有单词的子串的起始位置。 子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。 示例 1: 输入: s = “barfoothefoobarman”, words = [“foo”,”bar”]输出: [0,9]解释: 从索引 0 和 9 开始的子串分别是 “barfoor” 和 “foobar” 。输出的顺序不重要, [9,0] 也是有效答案。示例 2: 输入: s = “wordgoodstudentgoodword”, words = [“word”,”student”]输出: [] code 12345678910111213141516171819202122232425262728293031323334353637383940414243 func findSubstring(s string, words []string) []int &#123; if len(s) == 0|| len(words) == 0&#123; return nil &#125; m1 := make(map[string]int) for _,word:=range words&#123; m1[word] += 1 &#125; ret := []int&#123;&#125; sl := len(words[0]) for i:=0; i&lt;sl; i++&#123; cm := make(map[string]int) c := 0 ind := i for st:=i; st&lt;len(s)-len(words)*sl+1; &#123; w := s[ind:ind+sl] if wc,ok := m1[w]; ok&#123; if cm[w] == wc &#123; cm[s[st:st+sl]]-=1 c-- st += sl &#125;else&#123; cm[w] ++ ind += sl if c == len(words)-1 &#123; ret =append(ret, st) cm[s[st:st+sl]]-=1 st += sl &#125;else&#123; c++ &#125; &#125; &#125;else&#123; c = 0 ind += sl st = ind cm = make(map[string]int) &#125; &#125; &#125; return ret&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://ipiao.top/tags/leetcode/"}]},{"title":"Leetcode 11-20","date":"2018-12-26T07:03:58.000Z","path":"2018/12/26/Leetcode-11-20/","text":"11. 盛最多水的容器 给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 解: 1.如果可以使用暴力，很多事情就变得简单了。 code 123456789101112131415 func maxArea(height []int) int &#123; s:=0 for i:=0 ;i&lt;len(height)-1;i++&#123; for j:=i+1;j&lt;len(height);j++&#123; a:=height[j]*(j-i) if height[j]&gt; height[i]&#123; a = height[i]*(j-i) &#125; if a &gt; s&#123; s = a &#125; &#125; &#125; return s&#125; 2.双指针法 code 12345678910111213141516171819 func maxArea(height []int) int &#123; l := len(height) s := 0 i,j := 0,l-1 for i&lt;j &#123; var s1 int if height[i]&lt;height[j]&#123; s1 = height[i]*(j-i) i++ &#125;else&#123; s1 = height[j]*(j-i) j-- &#125; if s1 &gt; s&#123; s = s1 &#125; &#125; return s&#125; 12. 整数转罗马数字 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 code 123456789101112131415 func intToRoman(num int) string &#123; var base = []int&#123;1000,900, 500,400, 100,90, 50,40, 10,9,5,4,1&#125; var strs = []string&#123;\"M\",\"CM\", \"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\", \"IX\",\"V\",\"IV\",\"I\"&#125; ret := \"\" for i,b:=range base&#123; x := num/b num = num%b if x!=0&#123; for j:=0;j&lt;x;j++&#123; ret +=strs[i] &#125; &#125; &#125; return ret&#125; 13. 罗马数字转整数 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 code 123456789101112131415 func romanToInt(s string) int &#123; var base = []int&#123;1000,900, 500,400, 100,90, 50,40, 10,9,5,4,1&#125; var strs = []string&#123;\"M\",\"CM\", \"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\", \"IX\",\"V\",\"IV\",\"I\"&#125; ret:=0 for i:=0;i&lt; len(strs);&#123; if strings.HasPrefix(s,strs[i])&#123; ret+=base[i] s = s[len(strs[i]):] &#125;else&#123; i++ &#125; &#125; return ret&#125; 14. 最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 code 123456789101112131415 func longestCommonPrefix(strs []string) string &#123; if len(strs)==0&#123; // 如果空，返回“” return \"\" &#125; base:=strs[0] // 选取第一个字符串作为对比基串 for i:=0;i&lt;len(base);i++&#123; b:=base[i] for j:=1;j&lt;len(strs);j++&#123; // 按索引对比 if i&gt;=len(strs[j]) || strs[j][i]!=b&#123; return base[:i] // 不想等就返回 &#125; &#125; &#125; return base&#125; 15. 三数之和 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解: 1.分层循环 code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 func threeSum(nums []int) [][]int &#123; sort.Ints(nums) ret := [][]int&#123;&#125; l:=len(nums) for i:=0;i&lt; l-2; i++&#123; if nums[i] &gt; 0 &#123; break &#125; if i&gt;0 &amp;&amp; nums[i] == nums[i-1]&#123; continue &#125; ts := twoSum(nums[i+1:], -nums[i]) for _,s:=range ts&#123; ret = append(ret, []int&#123;nums[i], s[0], s[1]&#125;) &#125; &#125; return ret&#125;func twoSum(nums []int, n int)[][]int&#123; ret := [][]int&#123;&#125; for i:=0; i&lt;len(nums)-1;i++&#123; if nums[i]&gt;n/2&#123; break &#125; if i&gt;0 &amp;&amp; nums[i] == nums[i-1]&#123; continue &#125; o,has := one(nums[i+1:], n-nums[i]) if has&#123; ret = append(ret, []int&#123;nums[i], o&#125;) &#125; &#125; return ret&#125;func one(nums []int,n int) (int,bool) &#123; end:=len(nums)-1 start:=0 if nums[start] == n&#123; return nums[start],true &#125; if nums[end] == n&#123; return nums[end],true &#125; for start&lt;end &#123; mid := (start+end)/2 if mid &gt; start&#123; if nums[mid] == n&#123; return nums[mid],true &#125; if nums[mid]&gt;n &#123; end = mid &#125;else&#123; start = mid &#125; &#125;else&#123; break &#125; &#125; return 0,false&#125; 2.三指针法 code 12345678910111213141516171819202122232425262728293031 func threeSum(nums []int) [][]int &#123; ret := [][]int&#123;&#125; sort.Ints(nums) for i:=0; i&lt;len(nums)-2; i++&#123; if nums[i] &gt; 0&#123; break &#125; if i &gt; 0 &amp;&amp; nums[i] == nums[i-1]&#123; continue &#125; j, k := i+1, len(nums)-1 for j&lt;k &#123; if j &gt; i+1 &amp;&amp; nums[j] == nums[j-1]&#123; j++ continue &#125; if nums[i] + nums[j] + nums[k] == 0&#123; ret = append(ret, []int&#123;nums[i], nums[j], nums[k]&#125;) j++ k-- &#125;else if nums[i] + nums[j] + nums[k] &gt; 0&#123; k-- &#125;else&#123; j++ &#125; &#125; &#125; return ret&#125; 16. 最接近的三数之和 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 解: 三指针 code 1234567891011121314151617181920212223242526272829303132333435363738394041 func threeSumClosest(nums []int, target int) int &#123; sort.Ints(nums) det:=0 for i:=0; i&lt;len(nums)-2; i++&#123; if i == 0&#123; det = nums[0] + nums[1] + nums[len(nums)-1] - target &#125;else if nums[i] == nums[i-1]&#123; continue &#125; j, k := i+1, len(nums)-1 for j&lt;k &#123; if j &gt; i+1 &amp;&amp; nums[j] == nums[j-1]&#123; j++ continue &#125; temp := nums[i] + nums[j] + nums[k] - target if temp == 0&#123; return target &#125;else &#123; if abs(temp)&lt; abs(det) &#123; det = temp &#125; if temp &lt; 0&#123; j++ &#125;else&#123; k-- &#125; &#125; &#125; &#125; return det + target&#125;func abs(n int)int&#123; if n &lt; 0&#123; return -n &#125; return n&#125; 17. 电话号码的字母组合 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 code 1234567891011121314151617181920212223242526272829 // 当然可以做复用 func letterCombinations(digits string) []string &#123; numMap := map[byte][]string&#123; '2': []string&#123;\"a\", \"b\", \"c\"&#125;, '3': []string&#123;\"d\", \"e\", \"f\"&#125;, '4': []string&#123;\"g\", \"h\", \"i\"&#125;, '5': []string&#123;\"j\", \"k\", \"l\"&#125;, '6': []string&#123;\"m\", \"n\", \"o\"&#125;, '7': []string&#123;\"p\", \"q\", \"r\", \"s\"&#125;, '8': []string&#123;\"t\", \"u\", \"v\"&#125;, '9': []string&#123;\"w\", \"x\", \"y\", \"z\"&#125;, &#125; if len(digits) == 0&#123; return nil &#125; fm := numMap[digits[0]] if len(digits) == 1&#123; return fm &#125; em := letterCombinations(digits[1:]) ret := []string&#123;&#125; for _,f := range fm&#123; for _,e:=range em&#123; ret = append(ret , f+e) &#125; &#125; return ret &#125; 18. 四数之和 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 解:有一句mmp，不知当讲不当讲 code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 func fourSum(nums []int, target int) [][]int &#123; sort.Ints(nums) return kSum(nums, 4, target) &#125;// k&gt;=2func kSum(nums []int, k, target int)[][]int&#123; ret := [][]int&#123;&#125; if k == 2&#123; i, j := 0, len(nums)-1 for i &lt; j&#123; if nums[i] &gt; target/2&#123; break &#125; if i &gt; 0 &amp;&amp; nums[i] == nums[i-1]&#123; i++ continue &#125; if nums[i] + nums[j] == target&#123; ret = append(ret, []int&#123;nums[i], nums[j]&#125;) i++ j-- &#125;else if nums[i] + nums[j] &lt; target&#123; i++ &#125;else&#123; j-- &#125; &#125; &#125;else&#123; for i:=0; i&lt;len(nums) - k + 1; i++&#123; if nums[i] &gt; target/k &#123; break &#125; if i &gt; 0 &amp;&amp; nums[i] == nums[i-1]&#123; continue &#125; ts := kSum(nums[i+1:], k-1, target-nums[i]) for j:=range ts&#123; r := make([]int, k) r[0] = nums[i] copy(r[1:], ts[j]) ret = append(ret,r) &#125; &#125; &#125; return ret&#125; 19. 删除链表的倒数第N个节点 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 解: 从头节点与第n个节点同时移动，后一个节点移动至末尾，头节点将移动至倒数第n个节点 code 12345678910111213141516171819202122232425262728 /** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; first := head for i := 1; i &lt; n; i++ &#123; first = first.Next &#125; var npNode *ListNode second := head for first.Next != nil &#123; first = first.Next npNode = second second = second.Next &#125; if npNode == nil &#123; return second.Next &#125; npNode.Next = second.Next return head&#125; 20. 有效的括号 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 解: 经典栈 code 1234567891011121314151617181920 func isValid(s string) bool &#123; var match = map[byte]byte&#123; ')':'(', ']':'[', '&#125;':'&#123;', &#125; stack := []byte&#123;&#125; for _,b:= range []byte(s)&#123; switch b&#123; case '(','&#123;','[': stack = append(stack, b) case ')','&#125;',']': if len(stack) == 0 || stack[len(stack)-1] != match[b]&#123; return false &#125; stack = stack[:len(stack)-1] &#125; &#125; return len(stack) == 0&#125;","tags":[]},{"title":"AntDesign 圣诞节彩蛋","date":"2018-12-26T02:02:00.000Z","path":"2018/12/26/AntDesign-圣诞节彩蛋/","text":"Ho! Ho! Ho! 昨天，蚂蚁金服被喷了，原因是其开源带代码(https://github.com/ant-design/ant-design) 里埋下一个在圣诞节才触发的彩蛋。不凑巧的是，某部最近才发文，思想是“中国人不过洋节”。 于是,在第一个洋节就出了一堆彩蛋引发的事件，情节严重者就要失业、背锅。传称，“在代码里下毒”。AntDesign自然而然遭遇炮轰(https://github.com/ant-design/ant-design/issues/13848) 。 作为一名吃瓜群众，本着看戏不嫌热闹的精神，表示对开源者的支持。开源本来就是一项高度自由的活动。只不过不同于我们这类低等开发者，成功的开源框架有了大量的受众，或多或少会影响到这项受众的利益。但是在受众为开源框架锁惊叹，收到褒奖的时候，缺不见得有感恩戴德的表现。同时，某种习性让我们不由自主的找寻一个背锅侠，于是矛头指向开源者。但是，第一责任人不可否认的是开发者本人啊。且不说开发者的能力问题，开发本是开发者的职责，使用别人的框架是节省了不少成本的，甚至大多比自己做的好。在使用开源框架的时候，我想很多了都有承受bug的准备。可是，彩蛋和bug其实有什么区别呢。对于开发者，都是预料之外的问题罢了。","tags":[{"name":"吃瓜","slug":"吃瓜","permalink":"http://ipiao.top/tags/吃瓜/"}]},{"title":"Leetcode 6-10","date":"2018-12-25T07:14:00.000Z","path":"2018/12/25/Leetcode-6-10/","text":"6. Z 字形变换 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。比如输入字符串 为”LEETCODEISHIRING” 行数为 3 时，排列如下（忽略下划线）： L _ C _ I _ R E T O E S I I G E _ D _ H _ N之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。请你实现这个将字符串进行指定行数变换的函数。 解: 这是一个有规律的图形阵，没什么可说的，直接套规律公式，避免一切花里胡哨 code 123456789101112131415161718192021222324252627282930 func convert(s string, numRows int) string &#123; if numRows == 1&#123; return s &#125; rs := []rune(s) l := len(rs) ret := []rune&#123;&#125; for i := 0; i &lt; numRows; i++ &#123; j := 0 for &#123; ind := (2*numRows-2)*j + i if ind &lt; l &#123; ret = append(ret, rs[ind]) &#125; else &#123; break &#125; if i != 0 &amp;&amp; i != numRows-1 &#123; ind2 := (2*numRows-2)*(j+1) - i if ind2 &lt; l &#123; ret = append(ret, rs[ind2]) &#125; else &#123; break &#125; &#125; j++ &#125; &#125; return string(ret)&#125; 7. 整数反转 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转 code 123456789101112131415161718192021 func reverse(x int) int &#123; if x &lt; 0 &#123; return -(reverse(-x)) &#125; var y int32 = int32(x) bl := []int32&#123;&#125; for y &gt; 0 &#123; bl = append(bl, y%10) y = y / 10 &#125; var ret int32 for i := 0; i &lt; len(bl); i++ &#123; if ret &gt; (math.MaxInt32-bl[i])/10 &#123; return 0 &#125; ret = 10*ret + bl[i] &#125; return int(ret)&#125; 8. 字符串转换整数 (atoi) 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 func myAtoi(str string) int &#123; var max = math.MaxInt32 bas := 1 // 乘子 nbs := make([]int,0) start:=false for i:=range str&#123; b:=str[i] if !start&#123; if b==' '&#123; continue &#125; if b == '-'&#123; bas = -1 start = true continue &#125; else if b=='+'&#123; start = true continue &#125; else if '0'&lt;=b &amp;&amp; b&lt;='9'&#123; start = true &#125;else&#123; return 0 &#125; &#125; if '0'&lt;=b &amp;&amp; b&lt;='9'&#123; nbs=append(nbs,int(b-'0')) &#125;else&#123; break &#125; &#125; if bas == -1&#123; max += 1 &#125; ret:=0 for i:=0;i&lt;len(nbs);i++&#123; if ret&gt;max/10 || (ret==max/10 &amp;&amp; nbs[i]&gt;max%10)&#123; ret = max break &#125; ret = ret*10 + nbs[i] &#125; return bas * ret&#125; 9. 回文数 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 解: TIP:反转一半就可以了 code 1234567891011121314151617181920 func isPalindrome(x int) bool &#123; if x&lt;0&#123; return false &#125; if x==0&#123; return true &#125; var bl []int for x&gt;0&#123; bl = append(bl, x%10) x = x/10 &#125; l:=len(bl)/2 for i:=0;i&lt;l;i++&#123; if bl[i]!=bl[len(bl)-i-1]&#123; return false &#125; &#125; return true &#125; 10. 正则表达式匹配 给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘*’ 的正则表达式匹配。 ‘.’ 匹配任意单个字符。‘*’ 匹配零个或多个前面的元素。匹配应该覆盖整个字符串 (s) ，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 解: 递归，很明显的 code 123456789101112131415161718192021222324252627282930313233 func isMatch(s string, p string) bool &#123; lp := len(p) ls := len(s) if ls == 0 &amp;&amp; lp == 0&#123; return true &#125; if ls !=0 &amp;&amp; lp == 0 &#123; return false &#125; if ls == 0 &amp;&amp; lp!=0 &#123; if p[lp-1] == '*'&#123; if lp == 1&#123; return true &#125; return isMatch(s, p[:lp-2]) &#125; return false &#125; if p[lp-1] == '.' || p[lp-1] == s[ls-1]&#123; return isMatch(s[:ls-1], p[:lp-1]) &#125; if p[lp-1] == '*'&#123; if isMatch(s, p[:lp-2])&#123; return true &#125; if (s[ls-1] == p[lp-2] || p[lp-2] == '.') &#123; return isMatch(s[:ls-1], p); &#125; return false; &#125; return false&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://ipiao.top/tags/leetcode/"}]},{"title":"Leetcode 3","date":"2018-12-24T09:03:00.000Z","path":"2018/12/24/Leetcode-3/","text":"字符串的排列 给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。换句话说，第一个字符串的排列之一是第二个字符串的子串。注意： 输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间 code 12345678910111213141516171819202122232425262728293031323334353637383940414243 func checkInclusion(s1 string, s2 string) bool &#123; if len(s1) &gt; len(s2) &#123; // 长度比较 return false &#125; v1 := sumstring(s1) i:=len(s1) v2 := sumstring(s2[:i]) for i &lt;= len(s2) &#123; if i &gt; len(s1)&#123; v2 += int(s2[i-1]) - int(s2[i-len(s1)-1]) &#125; if v1 == v2 &#123; // 在字符值相等的情况下才去判断是否是排列 if p(s1, s2[i-len(s1):i]) &#123; return true &#125; &#125; i++ &#125; return false&#125;func sumstring(s string) int &#123; // 计算string值 sum := 0 for i := range s &#123; sum += int(s[i]) &#125; return sum&#125;func p(b1, b2 string) bool &#123; // 判断是否是排列，也可以用排序算法降低空间复杂度 m1 := make(map[byte]int) m2 := make(map[byte]int) for i := range b1 &#123; m1[b1[i]] += 1 m2[b2[i]] += 1 &#125; for b, i := range m1 &#123; if m2[b] != i &#123; return false &#125; &#125; return true&#125;","tags":[{"name":"字符串","slug":"字符串","permalink":"http://ipiao.top/tags/字符串/"}]},{"title":"Leetcode 1-5","date":"2018-12-24T08:15:00.000Z","path":"2018/12/24/Leetcode-1-5/","text":"1. 两数之和 给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 解: 目的是要返回数组下标。 如果不考虑空间复杂度 如果考虑时间复杂度，就要保留一份数组备份，空间复杂度至少O(n),然后对数组进行排序，通过二分法查找，时间复杂度最优的是O(nlogn) code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 func twoSum(nums []int, target int) []int &#123;m := make(map[int]int) for i := 0; i &lt; len(nums); i++ &#123; another := target - nums[i] if _, ok := m[another]; ok &#123; return []int&#123;m[another], i&#125; &#125; m[nums[i]] = i &#125; return nil &#125; func twoSum(nums []int, target int) []int &#123; onum := make([]int, len(nums)) copy(onum, nums) // 保留备份 // Onlgn sort.Ints(nums) // 原数组排序 var find = func(anum []int, dest int) int &#123; // 二分查找数组中是否存在值为dest的元素 start := 0 end := len(anum) - 1 var mid int for start &lt; end-1 &#123; mid = (start + end) / 2 if anum[mid] == dest &#123; return mid &#125; if anum[mid] &gt; dest &#123; end = mid &#125; else &#123; start = mid &#125; &#125; if anum[start] == dest &#123; return start &#125; if anum[end] == dest &#123; return end &#125; return -1 &#125; // 遍历数组匹配 for i := range nums &#123; if cj := find(nums[i+1:], target-nums[i]); cj != -1 &#123; var ret = make([]int, 0) for j := range onum &#123; if onum[j] == nums[i] || onum[j] == nums[i+1+cj] &#123; ret = append(ret, j) &#125; &#125; return ret &#125; &#125; return nil &#125; 2. 两数相加 给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字0之外，这两个数都不会以0开头。 解: 注意的只有两点 进位 链表遍历到最后做长度判断和拼接 code 123456789101112131415161718192021222324252627 /** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123; if l1 == nil&#123; return l2 &#125; if l2 == nil&#123; return l1 &#125; node := new(ListNode) sum := l1.Val + l2.Val node.Next = addTwoNumbers(l1.Next,l2.Next) if sum &lt;10&#123; node.Val = sum &#125;else&#123; node.Val = sum -10 node.Next = addTwoNumbers(node.Next, &amp;ListNode&#123;Val:1&#125;) &#125; return node&#125; 3. 无重复字符的最长子串 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度 code 123456789101112131415161718 func lengthOfLongestSubstring(s string) int &#123; var bMap = make(map[rune]int) // 存储字符索引，用于判断重复 var startInd = 0 // 有效点开始 var maxLen = 0 // 长度 for i, r := range s &#123; ind,ok := bMap[r] if ok &amp;&amp; ind &gt;= startInd &#123; // 判断是否在有效区间内重复 startInd = ind + 1 // 如果是，直接修改起始有效索引，没有比较的必要 &#125;else&#123; l := i - startInd + 1 // 否则，每一步计算当前有效区间长度，避免临界问题 if l &gt; maxLen&#123; // 与已有最大长度比较，如果超过最大长度就更新 maxLen = l &#125; &#125; bMap[r] = i // 赋值覆盖 &#125; return maxLen&#125; 4. 寻找两个有序数组的中位数 给定两个大小为m和n的有序数组nums1和nums2请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为O(log(m + n))。你可以假设nums1和nums2不会同时为空。 解：有序数组，要求时间复杂度是O(log)级别的，应该是要使用二分法的。但是直接的二分法似乎没有可行之路，逐步分析下，发现通过递归可以实现。 code 123456789101112131415161718192021222324252627282930313233343536373839404142 func findMedianSortedArrays(nums1 []int, nums2 []int) float64 &#123; total := len(nums1) + len(nums2) if total%2 == 1 &#123; return float64(findKthNum(nums1, nums2, total/2+1)) &#125; else &#123; return 0.5 * float64(findKthNum(nums1, nums2, total/2)+findKthNum(nums1, nums2, total/2+1)) &#125;&#125;// 查找第k个数func findKthNum(nums1, nums2 []int, k int) int &#123; l1, l2 := len(nums1), len(nums2) if l1 &gt; l2 &#123; return findKthNum(nums2, nums1, k) &#125; if l1 == 0 &#123; return nums2[k-1] &#125; if k == 1 &#123; if nums1[0] &lt; nums2[0] &#123; return nums1[0] &#125; else &#123; return nums2[0] &#125; &#125; var pa, pb int if l1 &lt; k/2 &#123; pa = l1 &#125; else &#123; pa = k / 2 &#125; pb = k - pa // 比较较小端可以直接去除，不可能落在那里面，类二分 if nums1[pa-1] &lt; nums2[pb-1] &#123; return findKthNum(nums1[pa:], nums2, k-pa) &#125; else if nums2[pb-1] &lt; nums1[pa-1] &#123; return findKthNum(nums1, nums2[pb:], k-pb) &#125; else &#123; return nums1[pa-1] &#125;&#125; 5. 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 解: 硬算 code 123456789101112131415161718192021222324252627282930313233343536 func longestPalindrome(s string) string &#123; rs := []rune(s) l := len(rs) if l&lt;=1&#123; return s &#125; mp := rs[0:1] // 最长子串 for i := 0; i &lt; l-1; i++ &#123; temp1 := findPalindrome(rs, i, i) if len(temp1) &gt; len(mp) &#123; mp = temp1 &#125; if rs[i] == rs[i+1] &#123; temp2 := findPalindrome(rs, i, i+1) if len(temp2) &gt; len(mp) &#123; mp = temp2 &#125; &#125; &#125; return string(mp)&#125;func findPalindrome(rs []rune, si, ei int) []rune &#123; for si &gt; 0 &amp;&amp; ei &lt; len(rs)-1 &#123; if rs[si-1] == rs[ei+1] &#123; si-- ei++ &#125; else &#123; break &#125; &#125; return rs[si : ei+1]&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://ipiao.top/tags/leetcode/"}]},{"title":"Project Euler 1","date":"2018-12-24T07:28:00.000Z","path":"2018/12/24/Project-Euler-1/","text":"1.3的倍数和5的倍数 如果我们列出10以内所有3或5的倍数，我们将得到3、5、6和9，这些数的和是23。求1000以内所有3或5的倍数的和。 中学经典求和问题。计算 和=3的倍数和+5的倍数和-15的倍数和。 1234 3的倍数和 s1 = 333*334/2*3 = 1668335的倍数和 s2 = 199*200/2*5 = 9950015的倍数和 s3 = 66*67/2*15 = 33165s = 233168 code 1 ... 2.偶斐波那契数 斐波那契数列中的每一项都是前两项的和。由1和2开始生成的斐波那契数列前10项为：1, 2, 3, 5, 8, 13, 21, 34, 55, 89, … 考虑该斐波那契数列中不超过四百万的项，求其中为偶数的项之和。。","tags":[{"name":"pe","slug":"pe","permalink":"http://ipiao.top/tags/pe/"}]},{"title":"链表（一）","date":"2018-12-17T03:27:00.000Z","path":"2018/12/17/快慢指针法/","text":"快慢指针法 基本算法：https://www.cnblogs.com/songdechiu/p/6686520.html 扩展应用：https://www.cnblogs.com/hxsyl/p/4395794.html 判断一个链表是否存在环 code 1234567891011121314151617181920212223242526272829 /** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head==null) return false; if(head.next==null) return false; if(head.next.next==null) return false; ListNode slow=head; ListNode fast=head; while(fast!=null &amp;&amp; fast.next!=null)&#123; slow=slow.next; fast=fast.next.next; if(fast==slow)&#123; return true; &#125; &#125; return false; &#125;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://ipiao.top/tags/leetcode/"},{"name":"链表","slug":"链表","permalink":"http://ipiao.top/tags/链表/"}]},{"title":"数——丑数","date":"2018-12-17T02:37:00.000Z","path":"2018/12/17/丑数计算/","text":"丑数计算 要求输入一个n数输出第n个丑数。丑数是素因子只有2,3,5,7… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123 package calimport ( \"math\" \"sort\")// Ugly 丑数，基础// base 素数数组 可以是 2,3,5|3,5,7type Ugly struct &#123; base []int // 基础素因子 bmul int // 基础素因子 乘积 cbase [][]int // 素因子对应的第i次计算次数 ranks [][]int // 素因子各次值排序&#125;// NewUgly 创建一个丑数计算基础func NewUgly(base []int) *Ugly &#123; sort.Ints(base) u := &amp;Ugly&#123; base: base, bmul: mul(base), &#125; u.calNext() return u&#125;// Get 获取第n个丑数func (u *Ugly) Get(n int) int &#123; for sumLen(u.ranks) &lt; n &#123; u.calNext() &#125; sl := 0 ret := 0 for i := range u.ranks &#123; li := len(u.ranks[i]) if sl+li &gt;= n &#123; ret = u.ranks[i][n-sl-1] break &#125; sl += li &#125; return ret&#125;// 第n次计算func (u *Ugly) calNext() &#123; var n = len(u.cbase) + 1 var bb = make([]int, len(u.base)) for i, b := range u.base &#123; bb[i] = maxc(pow(u.bmul, n), b) &#125; u.cbase = append(u.cbase, bb) // bn := make([]int, len(bb)) var rank []int min := pow(u.bmul, n-1) for autoAdd(bn, bb) &#123; pm := powmul(u.base, bn) if pm &gt; min &amp;&amp; pm &lt;= pow(u.bmul, n) &#123; rank = append(rank, pm) &#125; &#125; sort.Ints(rank) u.ranks = append(u.ranks, rank)&#125;// 多元排序自增// 返回是否还有下一个// ln下限func autoAdd(bn, ln []int) bool &#123; if bn[0] &lt; ln[0] &#123; bn[0]++ return true &#125; bn[0] = 0 if len(bn) == 1 &#123; return false &#125; return autoAdd(bn[1:], ln[1:])&#125;// 获取a以b为底的整数部分func maxc(a, b int) int &#123; return int(math.Log(float64(a)) / math.Log(float64(b)))&#125;// 获取乘积func mul(nums []int) int &#123; ret := 1 for _, n := range nums &#123; ret *= n &#125; return ret&#125;// 获取数组所有长度func sumLen(a [][]int) int &#123; l := 0 for _, aa := range a &#123; l += len(aa) &#125; return l&#125;func pow(x, n int) int &#123; if n == 0 &#123; return 1 &#125; ret := 1 for i := 0; i &lt; n; i++ &#123; ret *= x &#125; return ret&#125;func powmul(a, b []int) int &#123; var c = make([]int, len(a)) for i := range a &#123; c[i] = pow(a[i], b[i]) &#125; return mul(c)&#125; 测试代码 1234567 func TestUgly(t *testing.T) &#123; ug := NewUgly([]int&#123;2, 3, 5&#125;) n := ug.Get(1500) t.Log(n) t.Log(sumLen(ug.ranks)) // t.Log(ug.ranks)&#125; 返回结果,与网上一些博客给出的答案859963392有差距1个index，本人是以2作为第一个丑数的 1234567 go test -v -run 'TestUgly'=== RUN TestUgly--- PASS: TestUgly (0.00s) cal_test.go:32: 860934420 cal_test.go:33: 2254PASSok github.com/ipiao/metools/math/cal 0.006s 附上目标丑数附近的丑数序列 123 810000000 816293376 819200000 820125000 829440000 838860800 839808000 843750000849346560 850305600 854296875 859963392 860934420 864000000 874800000 878906250884736000 885735000 895795200 900000000 905969664 906992640 911250000","tags":[{"name":"博客迁移","slug":"博客迁移","permalink":"http://ipiao.top/tags/博客迁移/"},{"name":"leetcode","slug":"leetcode","permalink":"http://ipiao.top/tags/leetcode/"},{"name":"数","slug":"数","permalink":"http://ipiao.top/tags/数/"}]},{"title":"Go return,defer,panic执行分析","date":"2018-12-17T02:13:00.000Z","path":"2018/12/17/Go-return-defer-panic执行分析/","text":"基本原则 defer表示在函数结束前执行，并且多个defer是FILO的执行顺序 panic只会执行一个，recover的不算，后续的不会执行 return 返回与函数定义的是否带有返回参数是不一样的 return 和 defer 一个有返回值的函数，可以有以下2种定义: 123456789101112131415161718 // 不带有返回值参数func sum1(x,y int)int&#123; s := x+y return s // 假设返回参数是唯一变量s1，这里相当于显式的把s赋值给s1&#125; // 带有返回值参数func sum2(x,y int)(s int)&#123; s = x+y return // return的一定是s&#125;func main()&#123; s1 := sum1(1,2) s2 := sum2(1,2) print(s1) // 3 print(s2) // 3&#125; 这sum1和sum2结果是一样的，但是组合上defer，会有不一样结果: 12345678910111213141516171819202122 func sum3(x,y int)int&#123; s := x+y defer func()&#123; s += 2 // 第二步，对s进行自增运算，不影响s1的值 &#125;() return s // 第一步，把值赋予给s1&#125;func sum4(x,y int)(s int)&#123; s = x+y defer func()&#123; s += 2 // 第二步，对s进行自增运算，影响返回值s &#125;() return // 第一步，把值赋予给s本身(s2:=x+y;return s2是一样的)&#125;func main()&#123; s3 := sum3(1,2) s4 := sum4(1,2) println(s3) // 3 println(s4) // 5&#125; s3=3,s4=5，简单理解： 函数在开始执行的时候，先初始化了它的返回值，如果未声明，随机一个tempS,如果声明了，即s 在执行到return（返回标志）的时候赋值。 sum3函数先在执行到return时候，将tempS赋值为s，即3。由于s和tempS3是不同的变量，defer中的s+2就与tempS3无关。 sum4函数由于声明了返回变量s，return时候，如果是 return x+y，其实将x+y复制给s，如果直接return，可以理解为跳过了复制操作。在return之后的defer，s与sum3所谓的tempS3其实是一个，所以defer的操作是有效的。 defer 和 panic 12345678910111213141516171819202122232425262728 func main() &#123; var a int // fn1 defer func() &#123; a = 3 if err := recover(); err != nil &#123; a = 4 fmt.Println(\"++++\") f := err.(func() string) fmt.Println(err, f(), reflect.TypeOf(err).Kind().String()) &#125; else &#123; fmt.Println(\"fatal\") &#125; &#125;() // fn2 defer func() &#123; a = 2 if r := recover(); r != nil &#123; // 这里的recover()去掉感受一下效果 panic(r) &#125; panic(func() string &#123; return \"defer panic\" &#125;) &#125;() a = 1 panic(\"panic1\") // 这里的panic去掉感受一下效果 // panic(\"panic2\")&#125; 没什么好说的…","tags":[{"name":"go","slug":"go","permalink":"http://ipiao.top/tags/go/"},{"name":"博客迁移","slug":"博客迁移","permalink":"http://ipiao.top/tags/博客迁移/"}]},{"title":"Apns 推送表情问题","date":"2018-12-14T02:54:00.000Z","path":"2018/12/14/Apns-推送表情问题/","text":"Apns表情推送 1.常规的，服务端，尤其是go，发起apns推送是可以直接推送UTF-8表情的。 问题场景 发起apns推送，用户名中有emoji表情，推送结果显示不出来。 解决方案: 一顿操作以后，发现数据库字符是utf8mb4，字段字符集是utf8_general_ci。需要将字符集改成utf8_unicode_ci。有两种方式: 直接修改数据库配置，或者值修改相应字段的字符集 在程序中连接mysql的时候修改连接设置(基于对连接参数设置的支持)，charset=utf8mb4&amp;collation=utf8_unicode_ci。与前者的差异是，这种修改只是针对当前连接的，以及字符集修改是针对数据库的，会产生相应的效率问题。 问题补充: 发现在使用utf8_unicode_ci之后，数据库的插入出错(之前先插入缓存，所以问题没有及时发现)，所以在有插入需求的时候还是需要修改数据库的字段类型，这个时候发现utf8_unicode_ci就不是很好用，使用utf8mb4_general_ci 参考资料 apns文档 mysql Emoji存储方案 go 连接mysql参数设置","tags":[{"name":"apns","slug":"apns","permalink":"http://ipiao.top/tags/apns/"},{"name":"emoji","slug":"emoji","permalink":"http://ipiao.top/tags/emoji/"}]}]