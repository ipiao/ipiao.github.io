[{"title":"Leetcode 31-40","date":"2018-12-29T10:22:00.000Z","path":"2018/12/29/Leetcode-31-40/","text":"31. 下一个排列 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 解: 重点在于下一个的规则 code 12345678910111213141516171819202122232425262728293031323334 func nextPermutation(nums []int) &#123; for i:=len(nums) -1; i&gt;0; i-- &#123; if nums[i] &gt; nums[i-1]&#123; ind:=i for j:=i+1;j&lt;len(nums);j++&#123; if nums[j]&gt;nums[i-1] &amp;&amp; nums[j] &lt;= nums[ind]&#123; ind = j &#125; &#125; swap(nums, ind, i-1) reverse(nums[i:]) return &#125; &#125; reverse(nums)&#125;func reverse(nums []int) &#123; i := 0 j := len(nums) -1 for i &lt; j &#123; swap(nums,i,j) i++; j--; &#125;&#125;func swap(nums []int,i ,j int)&#123; tmp := nums[i] nums[i] = nums[j] nums[j] = tmp&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://ipiao.top/tags/leetcode/"}]},{"title":"Leetcode 21-30","date":"2018-12-27T07:17:00.000Z","path":"2018/12/27/Leetcode-21-30/","text":"21. 合并两个有序链表 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 code 123456789101112131415161718192021222324252627 /** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; if l1 == nil &#123; return l2 &#125; if l2 == nil &#123; return l1 &#125; var root = new(ListNode) if l1.Val &lt; l2.Val&#123; root.Val = l1.Val l1 = l1.Next &#125;else&#123; root.Val = l2.Val l2 = l2.Next &#125; if l1 !=nil || l2!=nil&#123; root.Next = mergeTwoLists(l1, l2) &#125; return root&#125; 22. 括号生成 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。例如，给出 n = 3，生成结果为：[ “((()))”, “(()())”, “(())()”, “()(())”, “()()()”] code 123456789101112131415161718 func generateParenthesis(n int) []string &#123; var ans = []string&#123;&#125; generate(&amp;ans, \"\", 0, 0, n) return ans&#125;func generate(ans *[]string,cur string,l int, r int, max int) &#123; if len(cur) == max*2&#123; *ans = append(*ans, cur) &#125; if l &lt; max&#123; generate(ans, cur + \"(\", l+1, r, max) &#125; if r &lt; l&#123; generate(ans, cur + \")\", l, r+1, max) &#125;&#125; 23. 合并K个排序链表 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 code 123456789101112131415161718 /** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func mergeKLists(lists []*ListNode) *ListNode &#123; if len(lists) == 0 &#123; return nil &#125; if len(lists) == 1&#123; return lists[0] &#125; return mergeTwoLists(mergeKLists(lists[:len(lists)/2]), mergeKLists(lists[len(lists)/2:]))&#125; 24. 两两交换链表中的节点 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。示例:给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.说明:你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 code 1234567891011121314151617 /** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func swapPairs(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil&#123; return head &#125; p := head head = head.Next p.Next = swapPairs(head.Next) head.Next = p return head&#125; 25. k个一组翻转链表 给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保&gt; 持原有顺序。示例 :给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5说明 :你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 code 123456789101112131415161718192021222324252627282930313233343536373839404142434445 /** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func reverseKGroup(head *ListNode, k int) *ListNode &#123; if k == 1&#123; return head &#125; fake := &amp;ListNode&#123;Next: head&#125; p := fake for p != nil&#123; p.Next = reverseKNodes(p.Next, k) for i:=0; p!=nil &amp;&amp; i&lt;k; i++&#123; p = p.Next &#125; &#125; return fake.Next&#125;func reverseKNodes(head *ListNode, k int) *ListNode &#123; end := head for end != nil &amp;&amp; k&gt;0&#123; // end 是结束后一个 end = end.Next k-- &#125; if k &gt; 0&#123; return head &#125; var qNode *ListNode var ret = end var node = head for node != end &#123; qNode = node.Next node.Next = ret ret = node node = qNode &#125; return ret&#125; 26. 删除排序数组中的重复项 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 code 1234567891011121314 func removeDuplicates(nums []int) int &#123; if len(nums) &lt;= 1&#123; return len(nums) &#125; newLen:=1 base:=nums[0] for i:=1; i&lt;len(nums); i++&#123; if nums[i] != base&#123; nums[newLen],newLen,base = nums[i],newLen+1,nums[i] &#125; &#125; return newLen&#125; 27. 移除元素 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 code 123456789101112 func removeElement(nums []int, val int) int &#123; ind:=0 ret:=0 for i:=range nums&#123; if nums[i] != val&#123; ret++ nums[ind] = nums[i] ind++ &#125; &#125; return ret&#125; 28. 实现strStr() 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 解: 经典 KMP 算法 code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 func strStr(haystack string, needle string) int &#123; if needle == \"\"&#123; return 0 &#125; return kmpIndex([]byte(haystack), []byte(needle))&#125;func kmpIndex(s, p []byte) int &#123; i := 0 j := 0 next := getNext(p) for i &lt; len(s) &amp;&amp; j &lt; len(p) &#123; if j == -1 || s[i] == p[j] &#123; i++ j++ &#125; else &#123; j = next[j] &#125; &#125; if j == len(p) &#123; return i - j &#125; return -1&#125;func getNext(ms []byte) []int &#123; length := len(ms) next := make([]int, length) next[0] = -1 k := -1 j := 0 for j &lt; length-1 &#123; if k == -1 || ms[j] == ms[k] &#123; j++ k++ if ms[j] != ms[k] &#123; next[j] = k &#125; else &#123; next[j] = next[k] &#125; &#125; else &#123; k = next[k] &#125; &#125; return next&#125; 29. 两数相除 给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。返回被除数 dividend 除以除数 divisor 得到的商。示例 1:输入: dividend = 10, divisor = 3输出: 3示例 2:输入: dividend = 7, divisor = -3输出: -2说明:被除数和除数均为 32 位有符号整数。除数不为 0。我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 解: 分治法 code 12345678910111213141516171819202122232425262728293031323334353637383940 func divide(dividend int, divisor int) int &#123; if dividend &lt; 0&#123; if dividend &gt; math.MinInt32&#123; if divisor == math.MinInt32&#123; return 0 &#125;else&#123; return divide(0-dividend, 0-divisor) &#125; &#125;else&#123; if divisor == math.MinInt32&#123; return 1 &#125;else if divisor == -1&#123; return math.MaxInt32 &#125; else&#123; if divisor &gt; 0&#123; return divide(divisor+dividend, divisor)-1 &#125;else&#123; return divide(dividend-divisor, divisor)+1 &#125; &#125; &#125; &#125; ret := 0 if divisor &gt; 0&#123; sum := divisor for sum &lt;= dividend&#123; ret++ sum += divisor &#125; &#125;else&#123; sum := 0-divisor for sum &lt;= dividend &#123; ret-- sum -= divisor &#125; &#125; return ret&#125; 30. 与所有单词相关联的字串 给定一个字符串 s 和一些长度相同的单词 words。在 s 中找出可以恰好串联 words 中所有单词的子串的起始位置。 子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。 示例 1: 输入: s = “barfoothefoobarman”, words = [“foo”,”bar”]输出: [0,9]解释: 从索引 0 和 9 开始的子串分别是 “barfoor” 和 “foobar” 。输出的顺序不重要, [9,0] 也是有效答案。示例 2: 输入: s = “wordgoodstudentgoodword”, words = [“word”,”student”]输出: [] code 12345678910111213141516171819202122232425262728293031323334353637383940414243 func findSubstring(s string, words []string) []int &#123; if len(s) == 0|| len(words) == 0&#123; return nil &#125; m1 := make(map[string]int) for _,word:=range words&#123; m1[word] += 1 &#125; ret := []int&#123;&#125; sl := len(words[0]) for i:=0; i&lt;sl; i++&#123; cm := make(map[string]int) c := 0 ind := i for st:=i; st&lt;len(s)-len(words)*sl+1; &#123; w := s[ind:ind+sl] if wc,ok := m1[w]; ok&#123; if cm[w] == wc &#123; cm[s[st:st+sl]]-=1 c-- st += sl &#125;else&#123; cm[w] ++ ind += sl if c == len(words)-1 &#123; ret =append(ret, st) cm[s[st:st+sl]]-=1 st += sl &#125;else&#123; c++ &#125; &#125; &#125;else&#123; c = 0 ind += sl st = ind cm = make(map[string]int) &#125; &#125; &#125; return ret&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://ipiao.top/tags/leetcode/"}]},{"title":"Leetcode 11-20","date":"2018-12-26T07:03:58.000Z","path":"2018/12/26/Leetcode-11-20/","text":"11. 盛最多水的容器 给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 解: 1.如果可以使用暴力，很多事情就变得简单了。 code 123456789101112131415 func maxArea(height []int) int &#123; s:=0 for i:=0 ;i&lt;len(height)-1;i++&#123; for j:=i+1;j&lt;len(height);j++&#123; a:=height[j]*(j-i) if height[j]&gt; height[i]&#123; a = height[i]*(j-i) &#125; if a &gt; s&#123; s = a &#125; &#125; &#125; return s&#125; 2.双指针法 code 12345678910111213141516171819 func maxArea(height []int) int &#123; l := len(height) s := 0 i,j := 0,l-1 for i&lt;j &#123; var s1 int if height[i]&lt;height[j]&#123; s1 = height[i]*(j-i) i++ &#125;else&#123; s1 = height[j]*(j-i) j-- &#125; if s1 &gt; s&#123; s = s1 &#125; &#125; return s&#125; 12. 整数转罗马数字 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 code 123456789101112131415 func intToRoman(num int) string &#123; var base = []int&#123;1000,900, 500,400, 100,90, 50,40, 10,9,5,4,1&#125; var strs = []string&#123;\"M\",\"CM\", \"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\", \"IX\",\"V\",\"IV\",\"I\"&#125; ret := \"\" for i,b:=range base&#123; x := num/b num = num%b if x!=0&#123; for j:=0;j&lt;x;j++&#123; ret +=strs[i] &#125; &#125; &#125; return ret&#125; 13. 罗马数字转整数 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 code 123456789101112131415 func romanToInt(s string) int &#123; var base = []int&#123;1000,900, 500,400, 100,90, 50,40, 10,9,5,4,1&#125; var strs = []string&#123;\"M\",\"CM\", \"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\", \"IX\",\"V\",\"IV\",\"I\"&#125; ret:=0 for i:=0;i&lt; len(strs);&#123; if strings.HasPrefix(s,strs[i])&#123; ret+=base[i] s = s[len(strs[i]):] &#125;else&#123; i++ &#125; &#125; return ret&#125; 14. 最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 code 123456789101112131415 func longestCommonPrefix(strs []string) string &#123; if len(strs)==0&#123; // 如果空，返回“” return \"\" &#125; base:=strs[0] // 选取第一个字符串作为对比基串 for i:=0;i&lt;len(base);i++&#123; b:=base[i] for j:=1;j&lt;len(strs);j++&#123; // 按索引对比 if i&gt;=len(strs[j]) || strs[j][i]!=b&#123; return base[:i] // 不想等就返回 &#125; &#125; &#125; return base&#125; 15. 三数之和 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解: 1.分层循环 code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 func threeSum(nums []int) [][]int &#123; sort.Ints(nums) ret := [][]int&#123;&#125; l:=len(nums) for i:=0;i&lt; l-2; i++&#123; if nums[i] &gt; 0 &#123; break &#125; if i&gt;0 &amp;&amp; nums[i] == nums[i-1]&#123; continue &#125; ts := twoSum(nums[i+1:], -nums[i]) for _,s:=range ts&#123; ret = append(ret, []int&#123;nums[i], s[0], s[1]&#125;) &#125; &#125; return ret&#125;func twoSum(nums []int, n int)[][]int&#123; ret := [][]int&#123;&#125; for i:=0; i&lt;len(nums)-1;i++&#123; if nums[i]&gt;n/2&#123; break &#125; if i&gt;0 &amp;&amp; nums[i] == nums[i-1]&#123; continue &#125; o,has := one(nums[i+1:], n-nums[i]) if has&#123; ret = append(ret, []int&#123;nums[i], o&#125;) &#125; &#125; return ret&#125;func one(nums []int,n int) (int,bool) &#123; end:=len(nums)-1 start:=0 if nums[start] == n&#123; return nums[start],true &#125; if nums[end] == n&#123; return nums[end],true &#125; for start&lt;end &#123; mid := (start+end)/2 if mid &gt; start&#123; if nums[mid] == n&#123; return nums[mid],true &#125; if nums[mid]&gt;n &#123; end = mid &#125;else&#123; start = mid &#125; &#125;else&#123; break &#125; &#125; return 0,false&#125; 2.三指针法 code 12345678910111213141516171819202122232425262728293031 func threeSum(nums []int) [][]int &#123; ret := [][]int&#123;&#125; sort.Ints(nums) for i:=0; i&lt;len(nums)-2; i++&#123; if nums[i] &gt; 0&#123; break &#125; if i &gt; 0 &amp;&amp; nums[i] == nums[i-1]&#123; continue &#125; j, k := i+1, len(nums)-1 for j&lt;k &#123; if j &gt; i+1 &amp;&amp; nums[j] == nums[j-1]&#123; j++ continue &#125; if nums[i] + nums[j] + nums[k] == 0&#123; ret = append(ret, []int&#123;nums[i], nums[j], nums[k]&#125;) j++ k-- &#125;else if nums[i] + nums[j] + nums[k] &gt; 0&#123; k-- &#125;else&#123; j++ &#125; &#125; &#125; return ret&#125; 16. 最接近的三数之和 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 解: 三指针 code 1234567891011121314151617181920212223242526272829303132333435363738394041 func threeSumClosest(nums []int, target int) int &#123; sort.Ints(nums) det:=0 for i:=0; i&lt;len(nums)-2; i++&#123; if i == 0&#123; det = nums[0] + nums[1] + nums[len(nums)-1] - target &#125;else if nums[i] == nums[i-1]&#123; continue &#125; j, k := i+1, len(nums)-1 for j&lt;k &#123; if j &gt; i+1 &amp;&amp; nums[j] == nums[j-1]&#123; j++ continue &#125; temp := nums[i] + nums[j] + nums[k] - target if temp == 0&#123; return target &#125;else &#123; if abs(temp)&lt; abs(det) &#123; det = temp &#125; if temp &lt; 0&#123; j++ &#125;else&#123; k-- &#125; &#125; &#125; &#125; return det + target&#125;func abs(n int)int&#123; if n &lt; 0&#123; return -n &#125; return n&#125; 17. 电话号码的字母组合 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 code 1234567891011121314151617181920212223242526272829 // 当然可以做复用 func letterCombinations(digits string) []string &#123; numMap := map[byte][]string&#123; '2': []string&#123;\"a\", \"b\", \"c\"&#125;, '3': []string&#123;\"d\", \"e\", \"f\"&#125;, '4': []string&#123;\"g\", \"h\", \"i\"&#125;, '5': []string&#123;\"j\", \"k\", \"l\"&#125;, '6': []string&#123;\"m\", \"n\", \"o\"&#125;, '7': []string&#123;\"p\", \"q\", \"r\", \"s\"&#125;, '8': []string&#123;\"t\", \"u\", \"v\"&#125;, '9': []string&#123;\"w\", \"x\", \"y\", \"z\"&#125;, &#125; if len(digits) == 0&#123; return nil &#125; fm := numMap[digits[0]] if len(digits) == 1&#123; return fm &#125; em := letterCombinations(digits[1:]) ret := []string&#123;&#125; for _,f := range fm&#123; for _,e:=range em&#123; ret = append(ret , f+e) &#125; &#125; return ret &#125; 18. 四数之和 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 解:有一句mmp，不知当讲不当讲 code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 func fourSum(nums []int, target int) [][]int &#123; sort.Ints(nums) return kSum(nums, 4, target) &#125;// k&gt;=2func kSum(nums []int, k, target int)[][]int&#123; ret := [][]int&#123;&#125; if k == 2&#123; i, j := 0, len(nums)-1 for i &lt; j&#123; if nums[i] &gt; target/2&#123; break &#125; if i &gt; 0 &amp;&amp; nums[i] == nums[i-1]&#123; i++ continue &#125; if nums[i] + nums[j] == target&#123; ret = append(ret, []int&#123;nums[i], nums[j]&#125;) i++ j-- &#125;else if nums[i] + nums[j] &lt; target&#123; i++ &#125;else&#123; j-- &#125; &#125; &#125;else&#123; for i:=0; i&lt;len(nums) - k + 1; i++&#123; if nums[i] &gt; target/k &#123; break &#125; if i &gt; 0 &amp;&amp; nums[i] == nums[i-1]&#123; continue &#125; ts := kSum(nums[i+1:], k-1, target-nums[i]) for j:=range ts&#123; r := make([]int, k) r[0] = nums[i] copy(r[1:], ts[j]) ret = append(ret,r) &#125; &#125; &#125; return ret&#125; 19. 删除链表的倒数第N个节点 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 解: 从头节点与第n个节点同时移动，后一个节点移动至末尾，头节点将移动至倒数第n个节点 code 12345678910111213141516171819202122232425262728 /** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; first := head for i := 1; i &lt; n; i++ &#123; first = first.Next &#125; var npNode *ListNode second := head for first.Next != nil &#123; first = first.Next npNode = second second = second.Next &#125; if npNode == nil &#123; return second.Next &#125; npNode.Next = second.Next return head&#125; 20. 有效的括号 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 解: 经典栈 code 1234567891011121314151617181920 func isValid(s string) bool &#123; var match = map[byte]byte&#123; ')':'(', ']':'[', '&#125;':'&#123;', &#125; stack := []byte&#123;&#125; for _,b:= range []byte(s)&#123; switch b&#123; case '(','&#123;','[': stack = append(stack, b) case ')','&#125;',']': if len(stack) == 0 || stack[len(stack)-1] != match[b]&#123; return false &#125; stack = stack[:len(stack)-1] &#125; &#125; return len(stack) == 0&#125;","tags":[]},{"title":"AntDesign 圣诞节彩蛋","date":"2018-12-26T02:02:00.000Z","path":"2018/12/26/AntDesign-圣诞节彩蛋/","text":"Ho! Ho! Ho! 昨天，蚂蚁金服被喷了，原因是其开源带代码(https://github.com/ant-design/ant-design) 里埋下一个在圣诞节才触发的彩蛋。不凑巧的是，某部最近才发文，思想是“中国人不过洋节”。 于是,在第一个洋节就出了一堆彩蛋引发的事件，情节严重者就要失业、背锅。传称，“在代码里下毒”。AntDesign自然而然遭遇炮轰(https://github.com/ant-design/ant-design/issues/13848) 。 作为一名吃瓜群众，本着看戏不嫌热闹的精神，表示对开源者的支持。开源本来就是一项高度自由的活动。只不过不同于我们这类低等开发者，成功的开源框架有了大量的受众，或多或少会影响到这项受众的利益。但是在受众为开源框架锁惊叹，收到褒奖的时候，缺不见得有感恩戴德的表现。同时，某种习性让我们不由自主的找寻一个背锅侠，于是矛头指向开源者。但是，第一责任人不可否认的是开发者本人啊。且不说开发者的能力问题，开发本是开发者的职责，使用别人的框架是节省了不少成本的，甚至大多比自己做的好。在使用开源框架的时候，我想很多了都有承受bug的准备。可是，彩蛋和bug其实有什么区别呢。对于开发者，都是预料之外的问题罢了。","tags":[{"name":"吃瓜","slug":"吃瓜","permalink":"http://ipiao.top/tags/吃瓜/"}]},{"title":"Leetcode 6-10","date":"2018-12-25T07:14:00.000Z","path":"2018/12/25/Leetcode-6-10/","text":"6. Z 字形变换 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。比如输入字符串 为”LEETCODEISHIRING” 行数为 3 时，排列如下（忽略下划线）： L _ C _ I _ R E T O E S I I G E _ D _ H _ N之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。请你实现这个将字符串进行指定行数变换的函数。 解: 这是一个有规律的图形阵，没什么可说的，直接套规律公式，避免一切花里胡哨 code 123456789101112131415161718192021222324252627282930 func convert(s string, numRows int) string &#123; if numRows == 1&#123; return s &#125; rs := []rune(s) l := len(rs) ret := []rune&#123;&#125; for i := 0; i &lt; numRows; i++ &#123; j := 0 for &#123; ind := (2*numRows-2)*j + i if ind &lt; l &#123; ret = append(ret, rs[ind]) &#125; else &#123; break &#125; if i != 0 &amp;&amp; i != numRows-1 &#123; ind2 := (2*numRows-2)*(j+1) - i if ind2 &lt; l &#123; ret = append(ret, rs[ind2]) &#125; else &#123; break &#125; &#125; j++ &#125; &#125; return string(ret)&#125; 7. 整数反转 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转 code 123456789101112131415161718192021 func reverse(x int) int &#123; if x &lt; 0 &#123; return -(reverse(-x)) &#125; var y int32 = int32(x) bl := []int32&#123;&#125; for y &gt; 0 &#123; bl = append(bl, y%10) y = y / 10 &#125; var ret int32 for i := 0; i &lt; len(bl); i++ &#123; if ret &gt; (math.MaxInt32-bl[i])/10 &#123; return 0 &#125; ret = 10*ret + bl[i] &#125; return int(ret)&#125; 8. 字符串转换整数 (atoi) 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 func myAtoi(str string) int &#123; var max = math.MaxInt32 bas := 1 // 乘子 nbs := make([]int,0) start:=false for i:=range str&#123; b:=str[i] if !start&#123; if b==' '&#123; continue &#125; if b == '-'&#123; bas = -1 start = true continue &#125; else if b=='+'&#123; start = true continue &#125; else if '0'&lt;=b &amp;&amp; b&lt;='9'&#123; start = true &#125;else&#123; return 0 &#125; &#125; if '0'&lt;=b &amp;&amp; b&lt;='9'&#123; nbs=append(nbs,int(b-'0')) &#125;else&#123; break &#125; &#125; if bas == -1&#123; max += 1 &#125; ret:=0 for i:=0;i&lt;len(nbs);i++&#123; if ret&gt;max/10 || (ret==max/10 &amp;&amp; nbs[i]&gt;max%10)&#123; ret = max break &#125; ret = ret*10 + nbs[i] &#125; return bas * ret&#125; 9. 回文数 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 解: TIP:反转一半就可以了 code 1234567891011121314151617181920 func isPalindrome(x int) bool &#123; if x&lt;0&#123; return false &#125; if x==0&#123; return true &#125; var bl []int for x&gt;0&#123; bl = append(bl, x%10) x = x/10 &#125; l:=len(bl)/2 for i:=0;i&lt;l;i++&#123; if bl[i]!=bl[len(bl)-i-1]&#123; return false &#125; &#125; return true &#125; 10. 正则表达式匹配 给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘*’ 的正则表达式匹配。 ‘.’ 匹配任意单个字符。‘*’ 匹配零个或多个前面的元素。匹配应该覆盖整个字符串 (s) ，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 解: 递归，很明显的 code 123456789101112131415161718192021222324252627282930313233 func isMatch(s string, p string) bool &#123; lp := len(p) ls := len(s) if ls == 0 &amp;&amp; lp == 0&#123; return true &#125; if ls !=0 &amp;&amp; lp == 0 &#123; return false &#125; if ls == 0 &amp;&amp; lp!=0 &#123; if p[lp-1] == '*'&#123; if lp == 1&#123; return true &#125; return isMatch(s, p[:lp-2]) &#125; return false &#125; if p[lp-1] == '.' || p[lp-1] == s[ls-1]&#123; return isMatch(s[:ls-1], p[:lp-1]) &#125; if p[lp-1] == '*'&#123; if isMatch(s, p[:lp-2])&#123; return true &#125; if (s[ls-1] == p[lp-2] || p[lp-2] == '.') &#123; return isMatch(s[:ls-1], p); &#125; return false; &#125; return false&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://ipiao.top/tags/leetcode/"}]},{"title":"Leetcode 3","date":"2018-12-24T09:03:00.000Z","path":"2018/12/24/Leetcode-3/","text":"字符串的排列 给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。换句话说，第一个字符串的排列之一是第二个字符串的子串。注意： 输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间 code 12345678910111213141516171819202122232425262728293031323334353637383940414243 func checkInclusion(s1 string, s2 string) bool &#123; if len(s1) &gt; len(s2) &#123; // 长度比较 return false &#125; v1 := sumstring(s1) i:=len(s1) v2 := sumstring(s2[:i]) for i &lt;= len(s2) &#123; if i &gt; len(s1)&#123; v2 += int(s2[i-1]) - int(s2[i-len(s1)-1]) &#125; if v1 == v2 &#123; // 在字符值相等的情况下才去判断是否是排列 if p(s1, s2[i-len(s1):i]) &#123; return true &#125; &#125; i++ &#125; return false&#125;func sumstring(s string) int &#123; // 计算string值 sum := 0 for i := range s &#123; sum += int(s[i]) &#125; return sum&#125;func p(b1, b2 string) bool &#123; // 判断是否是排列，也可以用排序算法降低空间复杂度 m1 := make(map[byte]int) m2 := make(map[byte]int) for i := range b1 &#123; m1[b1[i]] += 1 m2[b2[i]] += 1 &#125; for b, i := range m1 &#123; if m2[b] != i &#123; return false &#125; &#125; return true&#125;","tags":[{"name":"字符串","slug":"字符串","permalink":"http://ipiao.top/tags/字符串/"}]},{"title":"Leetcode 1-5","date":"2018-12-24T08:15:00.000Z","path":"2018/12/24/Leetcode-1-5/","text":"1. 两数之和 给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 解: 目的是要返回数组下标。 如果不考虑空间复杂度 如果考虑时间复杂度，就要保留一份数组备份，空间复杂度至少O(n),然后对数组进行排序，通过二分法查找，时间复杂度最优的是O(nlogn) code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 func twoSum(nums []int, target int) []int &#123;m := make(map[int]int) for i := 0; i &lt; len(nums); i++ &#123; another := target - nums[i] if _, ok := m[another]; ok &#123; return []int&#123;m[another], i&#125; &#125; m[nums[i]] = i &#125; return nil &#125; func twoSum(nums []int, target int) []int &#123; onum := make([]int, len(nums)) copy(onum, nums) // 保留备份 // Onlgn sort.Ints(nums) // 原数组排序 var find = func(anum []int, dest int) int &#123; // 二分查找数组中是否存在值为dest的元素 start := 0 end := len(anum) - 1 var mid int for start &lt; end-1 &#123; mid = (start + end) / 2 if anum[mid] == dest &#123; return mid &#125; if anum[mid] &gt; dest &#123; end = mid &#125; else &#123; start = mid &#125; &#125; if anum[start] == dest &#123; return start &#125; if anum[end] == dest &#123; return end &#125; return -1 &#125; // 遍历数组匹配 for i := range nums &#123; if cj := find(nums[i+1:], target-nums[i]); cj != -1 &#123; var ret = make([]int, 0) for j := range onum &#123; if onum[j] == nums[i] || onum[j] == nums[i+1+cj] &#123; ret = append(ret, j) &#125; &#125; return ret &#125; &#125; return nil &#125; 2. 两数相加 给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字0之外，这两个数都不会以0开头。 解: 注意的只有两点 进位 链表遍历到最后做长度判断和拼接 code 123456789101112131415161718192021222324252627 /** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123; if l1 == nil&#123; return l2 &#125; if l2 == nil&#123; return l1 &#125; node := new(ListNode) sum := l1.Val + l2.Val node.Next = addTwoNumbers(l1.Next,l2.Next) if sum &lt;10&#123; node.Val = sum &#125;else&#123; node.Val = sum -10 node.Next = addTwoNumbers(node.Next, &amp;ListNode&#123;Val:1&#125;) &#125; return node&#125; 3. 无重复字符的最长子串 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度 code 123456789101112131415161718 func lengthOfLongestSubstring(s string) int &#123; var bMap = make(map[rune]int) // 存储字符索引，用于判断重复 var startInd = 0 // 有效点开始 var maxLen = 0 // 长度 for i, r := range s &#123; ind,ok := bMap[r] if ok &amp;&amp; ind &gt;= startInd &#123; // 判断是否在有效区间内重复 startInd = ind + 1 // 如果是，直接修改起始有效索引，没有比较的必要 &#125;else&#123; l := i - startInd + 1 // 否则，每一步计算当前有效区间长度，避免临界问题 if l &gt; maxLen&#123; // 与已有最大长度比较，如果超过最大长度就更新 maxLen = l &#125; &#125; bMap[r] = i // 赋值覆盖 &#125; return maxLen&#125; 4. 寻找两个有序数组的中位数 给定两个大小为m和n的有序数组nums1和nums2请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为O(log(m + n))。你可以假设nums1和nums2不会同时为空。 解：有序数组，要求时间复杂度是O(log)级别的，应该是要使用二分法的。但是直接的二分法似乎没有可行之路，逐步分析下，发现通过递归可以实现。 code 123456789101112131415161718192021222324252627282930313233343536373839404142 func findMedianSortedArrays(nums1 []int, nums2 []int) float64 &#123; total := len(nums1) + len(nums2) if total%2 == 1 &#123; return float64(findKthNum(nums1, nums2, total/2+1)) &#125; else &#123; return 0.5 * float64(findKthNum(nums1, nums2, total/2)+findKthNum(nums1, nums2, total/2+1)) &#125;&#125;// 查找第k个数func findKthNum(nums1, nums2 []int, k int) int &#123; l1, l2 := len(nums1), len(nums2) if l1 &gt; l2 &#123; return findKthNum(nums2, nums1, k) &#125; if l1 == 0 &#123; return nums2[k-1] &#125; if k == 1 &#123; if nums1[0] &lt; nums2[0] &#123; return nums1[0] &#125; else &#123; return nums2[0] &#125; &#125; var pa, pb int if l1 &lt; k/2 &#123; pa = l1 &#125; else &#123; pa = k / 2 &#125; pb = k - pa // 比较较小端可以直接去除，不可能落在那里面，类二分 if nums1[pa-1] &lt; nums2[pb-1] &#123; return findKthNum(nums1[pa:], nums2, k-pa) &#125; else if nums2[pb-1] &lt; nums1[pa-1] &#123; return findKthNum(nums1, nums2[pb:], k-pb) &#125; else &#123; return nums1[pa-1] &#125;&#125; 5. 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 解: 硬算 code 123456789101112131415161718192021222324252627282930313233343536 func longestPalindrome(s string) string &#123; rs := []rune(s) l := len(rs) if l&lt;=1&#123; return s &#125; mp := rs[0:1] // 最长子串 for i := 0; i &lt; l-1; i++ &#123; temp1 := findPalindrome(rs, i, i) if len(temp1) &gt; len(mp) &#123; mp = temp1 &#125; if rs[i] == rs[i+1] &#123; temp2 := findPalindrome(rs, i, i+1) if len(temp2) &gt; len(mp) &#123; mp = temp2 &#125; &#125; &#125; return string(mp)&#125;func findPalindrome(rs []rune, si, ei int) []rune &#123; for si &gt; 0 &amp;&amp; ei &lt; len(rs)-1 &#123; if rs[si-1] == rs[ei+1] &#123; si-- ei++ &#125; else &#123; break &#125; &#125; return rs[si : ei+1]&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://ipiao.top/tags/leetcode/"}]},{"title":"Project Euler 1","date":"2018-12-24T07:28:00.000Z","path":"2018/12/24/Project-Euler-1/","text":"1.3的倍数和5的倍数 如果我们列出10以内所有3或5的倍数，我们将得到3、5、6和9，这些数的和是23。求1000以内所有3或5的倍数的和。 中学经典求和问题。计算 和=3的倍数和+5的倍数和-15的倍数和。 1234 3的倍数和 s1 = 333*334/2*3 = 1668335的倍数和 s2 = 199*200/2*5 = 9950015的倍数和 s3 = 66*67/2*15 = 33165s = 233168 code 1 ... 2.偶斐波那契数 斐波那契数列中的每一项都是前两项的和。由1和2开始生成的斐波那契数列前10项为：1, 2, 3, 5, 8, 13, 21, 34, 55, 89, … 考虑该斐波那契数列中不超过四百万的项，求其中为偶数的项之和。。","tags":[{"name":"pe","slug":"pe","permalink":"http://ipiao.top/tags/pe/"}]},{"title":"链表（一）","date":"2018-12-17T03:27:00.000Z","path":"2018/12/17/快慢指针法/","text":"快慢指针法 基本算法：https://www.cnblogs.com/songdechiu/p/6686520.html 扩展应用：https://www.cnblogs.com/hxsyl/p/4395794.html 判断一个链表是否存在环 code 1234567891011121314151617181920212223242526272829 /** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head==null) return false; if(head.next==null) return false; if(head.next.next==null) return false; ListNode slow=head; ListNode fast=head; while(fast!=null &amp;&amp; fast.next!=null)&#123; slow=slow.next; fast=fast.next.next; if(fast==slow)&#123; return true; &#125; &#125; return false; &#125;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://ipiao.top/tags/leetcode/"},{"name":"链表","slug":"链表","permalink":"http://ipiao.top/tags/链表/"}]},{"title":"数——丑数","date":"2018-12-17T02:37:00.000Z","path":"2018/12/17/丑数计算/","text":"丑数计算 要求输入一个n数输出第n个丑数。丑数是素因子只有2,3,5,7… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123 package calimport ( \"math\" \"sort\")// Ugly 丑数，基础// base 素数数组 可以是 2,3,5|3,5,7type Ugly struct &#123; base []int // 基础素因子 bmul int // 基础素因子 乘积 cbase [][]int // 素因子对应的第i次计算次数 ranks [][]int // 素因子各次值排序&#125;// NewUgly 创建一个丑数计算基础func NewUgly(base []int) *Ugly &#123; sort.Ints(base) u := &amp;Ugly&#123; base: base, bmul: mul(base), &#125; u.calNext() return u&#125;// Get 获取第n个丑数func (u *Ugly) Get(n int) int &#123; for sumLen(u.ranks) &lt; n &#123; u.calNext() &#125; sl := 0 ret := 0 for i := range u.ranks &#123; li := len(u.ranks[i]) if sl+li &gt;= n &#123; ret = u.ranks[i][n-sl-1] break &#125; sl += li &#125; return ret&#125;// 第n次计算func (u *Ugly) calNext() &#123; var n = len(u.cbase) + 1 var bb = make([]int, len(u.base)) for i, b := range u.base &#123; bb[i] = maxc(pow(u.bmul, n), b) &#125; u.cbase = append(u.cbase, bb) // bn := make([]int, len(bb)) var rank []int min := pow(u.bmul, n-1) for autoAdd(bn, bb) &#123; pm := powmul(u.base, bn) if pm &gt; min &amp;&amp; pm &lt;= pow(u.bmul, n) &#123; rank = append(rank, pm) &#125; &#125; sort.Ints(rank) u.ranks = append(u.ranks, rank)&#125;// 多元排序自增// 返回是否还有下一个// ln下限func autoAdd(bn, ln []int) bool &#123; if bn[0] &lt; ln[0] &#123; bn[0]++ return true &#125; bn[0] = 0 if len(bn) == 1 &#123; return false &#125; return autoAdd(bn[1:], ln[1:])&#125;// 获取a以b为底的整数部分func maxc(a, b int) int &#123; return int(math.Log(float64(a)) / math.Log(float64(b)))&#125;// 获取乘积func mul(nums []int) int &#123; ret := 1 for _, n := range nums &#123; ret *= n &#125; return ret&#125;// 获取数组所有长度func sumLen(a [][]int) int &#123; l := 0 for _, aa := range a &#123; l += len(aa) &#125; return l&#125;func pow(x, n int) int &#123; if n == 0 &#123; return 1 &#125; ret := 1 for i := 0; i &lt; n; i++ &#123; ret *= x &#125; return ret&#125;func powmul(a, b []int) int &#123; var c = make([]int, len(a)) for i := range a &#123; c[i] = pow(a[i], b[i]) &#125; return mul(c)&#125; 测试代码 1234567 func TestUgly(t *testing.T) &#123; ug := NewUgly([]int&#123;2, 3, 5&#125;) n := ug.Get(1500) t.Log(n) t.Log(sumLen(ug.ranks)) // t.Log(ug.ranks)&#125; 返回结果,与网上一些博客给出的答案859963392有差距1个index，本人是以2作为第一个丑数的 1234567 go test -v -run 'TestUgly'=== RUN TestUgly--- PASS: TestUgly (0.00s) cal_test.go:32: 860934420 cal_test.go:33: 2254PASSok github.com/ipiao/metools/math/cal 0.006s 附上目标丑数附近的丑数序列 123 810000000 816293376 819200000 820125000 829440000 838860800 839808000 843750000849346560 850305600 854296875 859963392 860934420 864000000 874800000 878906250884736000 885735000 895795200 900000000 905969664 906992640 911250000","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://ipiao.top/tags/leetcode/"},{"name":"博客迁移","slug":"博客迁移","permalink":"http://ipiao.top/tags/博客迁移/"},{"name":"数","slug":"数","permalink":"http://ipiao.top/tags/数/"}]},{"title":"Go return,defer,panic执行分析","date":"2018-12-17T02:13:00.000Z","path":"2018/12/17/Go-return-defer-panic执行分析/","text":"基本原则 defer表示在函数结束前执行，并且多个defer是FILO的执行顺序 panic只会执行一个，recover的不算，后续的不会执行 return 返回与函数定义的是否带有返回参数是不一样的 return 和 defer 一个有返回值的函数，可以有以下2种定义: 123456789101112131415161718 // 不带有返回值参数func sum1(x,y int)int&#123; s := x+y return s // 假设返回参数是唯一变量s1，这里相当于显式的把s赋值给s1&#125; // 带有返回值参数func sum2(x,y int)(s int)&#123; s = x+y return // return的一定是s&#125;func main()&#123; s1 := sum1(1,2) s2 := sum2(1,2) print(s1) // 3 print(s2) // 3&#125; 这sum1和sum2结果是一样的，但是组合上defer，会有不一样结果: 12345678910111213141516171819202122 func sum3(x,y int)int&#123; s := x+y defer func()&#123; s += 2 // 第二步，对s进行自增运算，不影响s1的值 &#125;() return s // 第一步，把值赋予给s1&#125;func sum4(x,y int)(s int)&#123; s = x+y defer func()&#123; s += 2 // 第二步，对s进行自增运算，影响返回值s &#125;() return // 第一步，把值赋予给s本身(s2:=x+y;return s2是一样的)&#125;func main()&#123; s3 := sum3(1,2) s4 := sum4(1,2) println(s3) // 3 println(s4) // 5&#125; s3=3,s4=5，简单理解： 函数在开始执行的时候，先初始化了它的返回值，如果未声明，随机一个tempS,如果声明了，即s 在执行到return（返回标志）的时候赋值。 sum3函数先在执行到return时候，将tempS赋值为s，即3。由于s和tempS3是不同的变量，defer中的s+2就与tempS3无关。 sum4函数由于声明了返回变量s，return时候，如果是 return x+y，其实将x+y复制给s，如果直接return，可以理解为跳过了复制操作。在return之后的defer，s与sum3所谓的tempS3其实是一个，所以defer的操作是有效的。 defer 和 panic 12345678910111213141516171819202122232425262728 func main() &#123; var a int // fn1 defer func() &#123; a = 3 if err := recover(); err != nil &#123; a = 4 fmt.Println(\"++++\") f := err.(func() string) fmt.Println(err, f(), reflect.TypeOf(err).Kind().String()) &#125; else &#123; fmt.Println(\"fatal\") &#125; &#125;() // fn2 defer func() &#123; a = 2 if r := recover(); r != nil &#123; // 这里的recover()去掉感受一下效果 panic(r) &#125; panic(func() string &#123; return \"defer panic\" &#125;) &#125;() a = 1 panic(\"panic1\") // 这里的panic去掉感受一下效果 // panic(\"panic2\")&#125; 没什么好说的…","tags":[{"name":"go","slug":"go","permalink":"http://ipiao.top/tags/go/"},{"name":"博客迁移","slug":"博客迁移","permalink":"http://ipiao.top/tags/博客迁移/"}]},{"title":"Apns 推送表情问题","date":"2018-12-14T02:54:00.000Z","path":"2018/12/14/Apns-推送表情问题/","text":"Apns表情推送 1.常规的，服务端，尤其是go，发起apns推送是可以直接推送UTF-8表情的。 问题场景 发起apns推送，用户名中有emoji表情，推送结果显示不出来。 解决方案: 一顿操作以后，发现数据库字符是utf8mb4，字段字符集是utf8_general_ci。需要将字符集改成utf8_unicode_ci。有两种方式: 直接修改数据库配置，或者值修改相应字段的字符集 在程序中连接mysql的时候修改连接设置(基于对连接参数设置的支持)，charset=utf8mb4&amp;collation=utf8_unicode_ci。与前者的差异是，这种修改只是针对当前连接的，以及字符集修改是针对数据库的，会产生相应的效率问题。 问题补充: 发现在使用utf8_unicode_ci之后，数据库的插入出错(之前先插入缓存，所以问题没有及时发现)，所以在有插入需求的时候还是需要修改数据库的字段类型，这个时候发现utf8_unicode_ci就不是很好用，使用utf8mb4_general_ci 参考资料 apns文档 mysql Emoji存储方案 go 连接mysql参数设置","tags":[{"name":"apns","slug":"apns","permalink":"http://ipiao.top/tags/apns/"},{"name":"emoji","slug":"emoji","permalink":"http://ipiao.top/tags/emoji/"}]}]